{"pageProps":{"detail":{"type":"音视频","sub":"ffmpeg","id":"ffmpeg-doc","content":"<div><p>原文链接：<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"http://ffmpeg.org/ffmpeg.html\">ffmpeg documentation</a></p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Synopsis\">1 Synopsis</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Description\">2 Description</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Detailed-description\">3 Detailed description</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Filtering\">3.1 Filtering</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Simple-filtergraphs\">3.1.1 Simple filtergraphs</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Complex-filtergraphs\">3.1.2 Complex filtergraphs</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Stream-copy\">3.2 Stream copy</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Stream-selection\">4 Stream selection</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Description-1\">4.1 Description</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Automatic-stream-selection\">4.1.1 Automatic stream selection</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Manual-stream-selection\">4.1.2 Manual stream selection</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Complex-filtergraphs-1\">4.1.3 Complex filtergraphs</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Stream-handling\">4.1.4 Stream handling</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Examples\">4.2 Examples</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Options\">5 Options</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Stream-specifiers-1\">5.1 Stream specifiers</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Generic-options\">5.2 Generic options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#AVOptions\">5.3 AVOptions</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Main-options\">5.4 Main options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Video-Options\">5.5 Video Options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Advanced-Video-options\">5.6 Advanced Video options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Audio-Options\">5.7 Audio Options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Advanced-Audio-options\">5.8 Advanced Audio options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Subtitle-options\">5.9 Subtitle options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Advanced-Subtitle-options\">5.10 Advanced Subtitle options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Advanced-options\">5.11 Advanced options</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Preset-files\">5.12 Preset files</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#ffpreset-files\">5.12.1 ffpreset files</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#avpreset-files\">5.12.2 avpreset files</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Examples-1\">6 Examples</a>\n<ul>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Video-and-Audio-grabbing\">6.1 Video and Audio grabbing</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#X11-grabbing\">6.2 X11 grabbing</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Video-and-Audio-file-format-conversion\">6.3 Video and Audio file format conversion</a></li>\n</ul>\n</li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#See-Also\">7 See Also</a></li>\n<li><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"#Authors\">8 Authors</a></li>\n</ul>\n<h2><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" id=\"Synopsis\">1 Synopsis</a></h2>\n<pre><code class=\"language-shell\">ffmpeg [global_options] {[input_file_options] -i [input_url]} ... {[output_file_options] [output_url]} ...\n</code></pre>\n<h2>2 Description</h2>\n<p><code>ffmpeg</code> is a very fast video and audio converter that can also grab from<br>\na live audio/video source. It can also convert between arbitrary sample<br>\nrates and resize video on the fly with a high quality polyphase filter.</p>\n<p><code>ffmpeg</code> reads from an arbitrary number of input &quot;files&quot; (which can be regular<br>\nfiles, pipes, network streams, grabbing devices, etc.), specified by the<br>\n<code>-i</code> option, and writes to an arbitrary number of output &quot;files&quot;, which are<br>\nspecified by a plain output url. Anything found on the command line which<br>\ncannot be interpreted as an option is considered to be an output url.</p>\n<p>Each input or output url can, in principle, contain any number of streams of<br>\ndifferent types (video/audio/subtitle/attachment/data). The allowed number and/or<br>\ntypes of streams may be limited by the container format. Selecting which<br>\nstreams from which inputs will go into which output is either done automatically<br>\nor with the <code>-map</code> option (see the Stream selection chapter).</p>\n<p>To refer to input files in options, you must use their indices (0-based). E.g.<br>\nthe first input file is <code>0</code>, the second is <code>1</code>, etc. Similarly, streams<br>\nwithin a file are referred to by their indices. E.g. <code>2:3</code> refers to the<br>\nfourth stream in the third input file. Also see the Stream specifiers chapter.</p>\n<p>As a general rule, options are applied to the next specified<br>\nfile. Therefore, order is important, and you can have the same<br>\noption on the command line multiple times. Each occurrence is<br>\nthen applied to the next input or output file.<br>\nExceptions from this rule are the global options (e.g. verbosity level),<br>\nwhich should be specified first.</p>\n<p>Do not mix input and output files – first specify all input files, then all<br>\noutput files. Also do not mix options which belong to different files. All<br>\noptions apply ONLY to the next input or output file and are reset between files.</p>\n<ul>\n<li>To set the video bitrate of the output file to 64 kbit/s:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi\n</code></pre>\n<ul>\n<li>To force the frame rate of the output file to 24 fps:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i input.avi -r 24 output.avi\n</code></pre>\n<ul>\n<li>To force the frame rate of the input file (valid for raw formats only)<br>\nto 1 fps and the frame rate of the output file to 24 fps:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -r 1 -i input.m2v -r 24 output.avi\n</code></pre>\n<p>The format option may be needed for raw input files.</p>\n<h2>3 Detailed description</h2>\n<p>The transcoding process in <code>ffmpeg</code> for each output can be described by<br>\nthe following diagram:</p>\n<pre><code class=\"language-shell\"> _______              ______________\n|       |            |              |\n| input |  demuxer   | encoded data |   decoder\n| file  | ---------&amp;gt; | packets      | -----+\n|_______|            |______________|      |\n                                           v\n                                       _________\n                                      |         |\n                                      | decoded |\n                                      | frames  |\n                                      |_________|\n ________             ______________       |\n|        |           |              |      |\n| output | &amp;lt;-------- | encoded data | &amp;lt;----+\n| file   |   muxer   | packets      |   encoder\n|________|           |______________|\n</code></pre>\n<p><code>ffmpeg</code> calls the libavformat library (containing demuxers) to read<br>\ninput files and get packets containing encoded data from them. When there are<br>\nmultiple input files, <code>ffmpeg</code> tries to keep them synchronized by<br>\ntracking lowest timestamp on any active input stream.</p>\n<p>Encoded packets are then passed to the decoder (unless streamcopy is selected<br>\nfor the stream, see further for a description). The decoder produces<br>\nuncompressed frames (raw video/PCM audio/...) which can be processed further by<br>\nfiltering (see next section). After filtering, the frames are passed to the<br>\nencoder, which encodes them and outputs encoded packets. Finally those are<br>\npassed to the muxer, which writes the encoded packets to the output file.</p>\n<h3>3.1 Filtering</h3>\n<p>Before encoding, <code>ffmpeg</code> can process raw audio and video frames using<br>\nfilters from the libavfilter library. Several chained filters form a filter<br>\ngraph. <code>ffmpeg</code> distinguishes between two types of filtergraphs:<br>\nsimple and complex.</p>\n<h4>3.1.1 Simple filtergraphs</h4>\n<p>Simple filtergraphs are those that have exactly one input and output, both of<br>\nthe same type. In the above diagram they can be represented by simply inserting<br>\nan additional step between decoding and encoding:</p>\n<pre><code class=\"language-shell\"> _________                        ______________\n|         |                      |              |\n| decoded |                      | encoded data |\n| frames  |\\                   _ | packets      |\n|_________| \\                  /||______________|\n             \\   __________   /\n  simple     _\\||          | /  encoder\n  filtergraph   | filtered |/\n                | frames   |\n                |__________|\n</code></pre>\n<p>Simple filtergraphs are configured with the per-stream [-filter] option<br>\n(with [-vf] and [-af] aliases for video and audio respectively).<br>\nA simple filtergraph for video can look for example like this:</p>\n<pre><code class=\"language-shell\"> _______        _____________        _______        ________\n|       |      |             |      |       |      |        |\n| input | ---&amp;gt; | deinterlace | ---&amp;gt; | scale | ---&amp;gt; | output |\n|_______|      |_____________|      |_______|      |________|\n</code></pre>\n<p>Note that some filters change frame properties but not frame contents. E.g. the<br>\n<code>fps</code> filter in the example above changes number of frames, but does not<br>\ntouch the frame contents. Another example is the <code>setpts</code> filter, which<br>\nonly sets timestamps and otherwise passes the frames unchanged.</p>\n<h4>3.1.2 Complex filtergraphs</h4>\n<p>Complex filtergraphs are those which cannot be described as simply a linear<br>\nprocessing chain applied to one stream. This is the case, for example, when the graph has<br>\nmore than one input and/or output, or when output stream type is different from<br>\ninput. They can be represented with the following diagram:</p>\n<pre><code class=\"language-shell\"> _________\n|         |\n| input 0 |\\                    __________\n|_________| \\                  |          |\n             \\   _________    /| output 0 |\n              \\ |         |  / |__________|\n _________     \\| complex | /\n|         |     |         |/\n| input 1 |----&amp;gt;| filter  |\\\n|_________|     |         | \\   __________\n               /| graph   |  \\ |          |\n              / |         |   \\| output 1 |\n _________   /  |_________|    |__________|\n|         | /\n| input 2 |/\n|_________|\n</code></pre>\n<p>Complex filtergraphs are configured with the [-filter_complex] option.<br>\nNote that this option is global, since a complex filtergraph, by its nature,<br>\ncannot be unambiguously associated with a single stream or file.</p>\n<p>The [-lavfi] option is equivalent to [-filter_complex].</p>\n<p>A trivial example of a complex filtergraph is the <code>overlay</code> filter, which<br>\nhas two video inputs and one video output, containing one video overlaid on top<br>\nof the other. Its audio counterpart is the <code>amix</code> filter.</p>\n<h3>3.2 Stream copy</h3>\n<p>Stream copy is a mode selected by supplying the <code>copy</code> parameter to the<br>\n[-codec] option. It makes <code>ffmpeg</code> omit the decoding and encoding<br>\nstep for the specified stream, so it does only demuxing and muxing. It is useful<br>\nfor changing the container format or modifying container-level metadata. The<br>\ndiagram above will, in this case, simplify to this:</p>\n<pre><code class=\"language-shell\"> _______              ______________            ________\n|       |            |              |          |        |\n| input |  demuxer   | encoded data |  muxer   | output |\n| file  | ---------&amp;gt; | packets      | -------&amp;gt; | file   |\n|_______|            |______________|          |________|\n</code></pre>\n<p>Since there is no decoding or encoding, it is very fast and there is no quality<br>\nloss. However, it might not work in some cases because of many factors. Applying<br>\nfilters is obviously also impossible, since filters work on uncompressed data.</p>\n<h2>4 Stream selection</h2>\n<p><code>ffmpeg</code> provides the <code>-map</code> option for manual control of stream selection in each<br>\noutput file. Users can skip <code>-map</code> and let ffmpeg perform automatic stream selection as<br>\ndescribed below. The <code>-vn / -an / -sn / -dn</code> options can be used to skip inclusion of<br>\nvideo, audio, subtitle and data streams respectively, whether manually mapped or automatically<br>\nselected, except for those streams which are outputs of complex filtergraphs.</p>\n<h3>4.1 Description</h3>\n<p>The sub-sections that follow describe the various rules that are involved in stream selection.<br>\nThe examples that follow next show how these rules are applied in practice.</p>\n<p>While every effort is made to accurately reflect the behavior of the program, FFmpeg is under<br>\ncontinuous development and the code may have changed since the time of this writing.</p>\n<h4>4.1.1 Automatic stream selection</h4>\n<p>In the absence of any map options for a particular output file, ffmpeg inspects the output<br>\nformat to check which type of streams can be included in it, viz. video, audio and/or<br>\nsubtitles. For each acceptable stream type, ffmpeg will pick one stream, when available,<br>\nfrom among all the inputs.</p>\n<p>It will select that stream based upon the following criteria:</p>\n<ul>\n<li>for video, it is the stream with the highest resolution,</li>\n<li>for audio, it is the stream with the most channels,</li>\n<li>for subtitles, it is the first subtitle stream found but there’s a caveat.<br>\nThe output format’s default subtitle encoder can be either text-based or image-based,<br>\nand only a subtitle stream of the same type will be chosen.</li>\n</ul>\n<p>In the case where several streams of the same type rate equally, the stream with the lowest<br>\nindex is chosen.</p>\n<p>Data or attachment streams are not automatically selected and can only be included<br>\nusing <code>-map</code>.</p>\n<h4>4.1.2 Manual stream selection</h4>\n<p>When <code>-map</code> is used, only user-mapped streams are included in that output file,<br>\nwith one possible exception for filtergraph outputs described below.</p>\n<h4>4.1.3 Complex filtergraphs</h4>\n<p>If there are any complex filtergraph output streams with unlabeled pads, they will be added<br>\nto the first output file. This will lead to a fatal error if the stream type is not supported<br>\nby the output format. In the absence of the map option, the inclusion of these streams leads<br>\nto the automatic stream selection of their types being skipped. If map options are present,<br>\nthese filtergraph streams are included in addition to the mapped streams.</p>\n<p>Complex filtergraph output streams with labeled pads must be mapped once and exactly once.</p>\n<h4>4.1.4 Stream handling</h4>\n<p>Stream handling is independent of stream selection, with an exception for subtitles described<br>\nbelow. Stream handling is set via the <code>-codec</code> option addressed to streams within a<br>\nspecific <em>output</em> file. In particular, codec options are applied by ffmpeg after the<br>\nstream selection process and thus do not influence the latter. If no <code>-codec</code> option is<br>\nspecified for a stream type, ffmpeg will select the default encoder registered by the output<br>\nfile muxer.</p>\n<p>An exception exists for subtitles. If a subtitle encoder is specified for an output file, the<br>\nfirst subtitle stream found of any type, text or image, will be included. ffmpeg does not validate<br>\nif the specified encoder can convert the selected stream or if the converted stream is acceptable<br>\nwithin the output format. This applies generally as well: when the user sets an encoder manually,<br>\nthe stream selection process cannot check if the encoded stream can be muxed into the output file.<br>\nIf it cannot, ffmpeg will abort and <em>all</em> output files will fail to be processed.</p>\n<h3>4.2 Examples</h3>\n<p>The following examples illustrate the behavior, quirks and limitations of ffmpeg’s stream<br>\nselection methods.</p>\n<p>They assume the following three input files.</p>\n<pre><code class=\"language-shell\">input file 'A.avi'\n      stream 0: video 640x360\n      stream 1: audio 2 channels\n\ninput file 'B.mp4'\nstream 0: video 1920x1080\nstream 1: audio 2 channels\nstream 2: subtitles (text)\nstream 3: audio 5.1 channels\nstream 4: subtitles (text)\n\ninput file 'C.mkv'\nstream 0: video 1280x720\nstream 1: audio 2 channels\nstream 2: subtitles (image)\n</code></pre>\n<h4>Example: automatic stream selection</h4>\n<pre><code class=\"language-shell\">ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov\n</code></pre>\n<p>There are three output files specified, and for the first two, no <code>-map</code> options<br>\nare set, so ffmpeg will select streams for these two files automatically.</p>\n<p>out1.mkv is a Matroska container file and accepts video, audio and subtitle streams,<br>\nso ffmpeg will try to select one of each type.For video, it will select <code>stream 0</code> from<br>\nB.mp4, which has the highest<br>\nresolution among all the input video streams.For audio, it will select <code>stream 3</code> from<br>\nB.mp4, since it has the greatest<br>\nnumber of channels.For subtitles, it will select <code>stream 2</code> from B.mp4, which is the<br>\nfirst subtitle<br>\nstream from among A.avi and B.mp4.</p>\n<p>out2.wav accepts only audio streams, so only <code>stream 3</code> from B.mp4 is<br>\nselected.</p>\n<p>For out3.mov, since a <code>-map</code> option is set, no automatic stream selection will<br>\noccur. The <code>-map 1:a</code> option will select all audio streams from the second input<br>\nB.mp4. No other streams will be included in this output file.</p>\n<p>For the first two outputs, all included streams will be transcoded. The encoders chosen will<br>\nbe the default ones registered by each output format, which may not match the codec of the<br>\nselected input streams.</p>\n<p>For the third output, codec option for audio streams has been set<br>\nto <code>copy</code>, so no decoding-filtering-encoding operations will occur, or can occur.<br>\nPackets of selected streams shall be conveyed from the input file and muxed within the output<br>\nfile.</p>\n<h4>Example: automatic subtitles selection</h4>\n<pre><code class=\"language-shell\">ffmpeg -i C.mkv out1.mkv -c:s dvdsub -an out2.mkv\n</code></pre>\n<p>Although out1.mkv is a Matroska container file which accepts subtitle streams, only a<br>\nvideo and audio stream shall be selected. The subtitle stream of C.mkv is image-based<br>\nand the default subtitle encoder of the Matroska muxer is text-based, so a transcode operation<br>\nfor the subtitles is expected to fail and hence the stream isn’t selected. However, in<br>\nout2.mkv, a subtitle encoder is specified in the command and so, the subtitle stream is<br>\nselected, in addition to the video stream. The presence of <code>-an</code> disables audio stream<br>\nselection for out2.mkv.</p>\n<h4>Example: unlabeled filtergraph outputs</h4>\n<pre><code class=\"language-shell\">ffmpeg -i A.avi -i C.mkv -i B.mp4 -filter_complex &quot;overlay&quot; out1.mp4 out2.srt\n</code></pre>\n<p>A filtergraph is setup here using the <code>-filter_complex</code> option and consists of a single<br>\nvideo filter. The <code>overlay</code> filter requires exactly two video inputs, but none are<br>\nspecified, so the first two available video streams are used, those of A.avi and<br>\n[C.mkv]. The output pad of the filter has no label and so is sent to the first output file<br>\n[out1.mp4]. Due to this, automatic selection of the video stream is skipped, which would<br>\nhave selected the stream in B.mp4. The audio stream with most channels viz. <code>stream 3</code><br>\nin B.mp4, is chosen automatically. No subtitle stream is chosen however, since the MP4<br>\nformat has no default subtitle encoder registered, and the user hasn’t specified a subtitle encoder.</p>\n<p>The 2nd output file, [out2.srt], only accepts text-based subtitle streams. So, even though<br>\nthe first subtitle stream available belongs to [C.mkv], it is image-based and hence skipped.<br>\nThe selected stream, <code>stream 2</code> in B.mp4, is the first text-based subtitle stream.</p>\n<h4>Example: labeled filtergraph outputs</h4>\n<pre><code class=\"language-shell\">ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \\\n       -map '[outv]' -an        out1.mp4 \\\n                                out2.mkv \\\n       -map '[outv]' -map 1:a:0 out3.mkv\n</code></pre>\n<p>The above command will fail, as the output pad labelled <code>[outv]</code> has been mapped twice.<br>\nNone of the output files shall be processed.</p>\n<pre><code class=\"language-shell\">ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0[outv];overlay;aresample&quot; \\\n       -an        out1.mp4 \\\n                  out2.mkv \\\n       -map 1:a:0 out3.mkv\n</code></pre>\n<p>This command above will also fail as the hue filter output has a label, <code>[outv]</code>,<br>\nand hasn’t been mapped anywhere.</p>\n<p>The command should be modified as follows,</p>\n<pre><code class=\"language-shell\">ffmpeg -i A.avi -i B.mp4 -i C.mkv -filter_complex &quot;[1:v]hue=s=0,split=2[outv1][outv2];overlay;aresample&quot; \\\n        -map '[outv1]' -an        out1.mp4 \\\n                                  out2.mkv \\\n        -map '[outv2]' -map 1:a:0 out3.mkv\n</code></pre>\n<p>The video stream from B.mp4 is sent to the hue filter, whose output is cloned once using<br>\nthe split filter, and both outputs labelled. Then a copy each is mapped to the first and third<br>\noutput files.</p>\n<p>The overlay filter, requiring two video inputs, uses the first two unused video streams. Those<br>\nare the streams from A.avi and [C.mkv]. The overlay output isn’t labelled, so it is<br>\nsent to the first output file [out1.mp4], regardless of the presence of the <code>-map</code><br>\noption.</p>\n<p>The aresample filter is sent the first unused audio stream, that of A.avi. Since this filter<br>\noutput is also unlabelled, it too is mapped to the first output file. The presence of <code>-an</code><br>\nonly suppresses automatic or manual stream selection of audio streams, not outputs sent from<br>\nfiltergraphs. Both these mapped streams shall be ordered before the mapped stream in [out1.mp4].</p>\n<p>The video, audio and subtitle streams mapped to <code>out2.mkv</code> are entirely determined by<br>\nautomatic stream selection.</p>\n<p>[out3.mkv] consists of the cloned video output from the hue filter and the first audio<br>\nstream from B.mp4.</p>\n<h2>5 Options</h2>\n<p>All the numerical options, if not specified otherwise, accept a string<br>\nrepresenting a number as input, which may be followed by one of the SI<br>\nunit prefixes, for example: ’K’, ’M’, or ’G’.</p>\n<p>If ’i’ is appended to the SI unit prefix, the complete prefix will be<br>\ninterpreted as a unit prefix for binary multiples, which are based on<br>\npowers of 1024 instead of powers of 1000. Appending ’B’ to the SI unit<br>\nprefix multiplies the value by 8. This allows using, for example:<br>\n’KB’, ’MiB’, ’G’ and ’B’ as number suffixes.</p>\n<p>Options which do not take arguments are boolean options, and set the<br>\ncorresponding value to true. They can be set to false by prefixing<br>\nthe option name with &quot;no&quot;. For example using &quot;-nofoo&quot;<br>\nwill set the boolean option with name &quot;foo&quot; to false.</p>\n<h3>5.1 Stream specifiers</h3>\n<p>Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers<br>\nare used to precisely specify which stream(s) a given option belongs to.</p>\n<p>A stream specifier is a string generally appended to the option name and<br>\nseparated from it by a colon. E.g. <code>-codec:a:1 ac3</code> contains the<br>\n<code>a:1</code> stream specifier, which matches the second audio stream. Therefore, it<br>\nwould select the ac3 codec for the second audio stream.</p>\n<p>A stream specifier can match several streams, so that the option is applied to all<br>\nof them. E.g. the stream specifier in <code>-b:a 128k</code> matches all audio<br>\nstreams.</p>\n<p>An empty stream specifier matches all streams. For example, <code>-codec copy</code><br>\nor <code>-codec: copy</code> would copy all the streams without reencoding.</p>\n<p>Possible forms of stream specifiers are:</p>\n<p><em>stream_index</em></p>\n<ul>\n<li>Matches the stream with this index. E.g. <code>-threads:1 4</code> would set the<br>\nthread count for the second stream to 4. If stream_index is used as an<br>\nadditional stream specifier (see below), then it selects stream number<br>\nstream_index from the matching streams. Stream numbering is based on the<br>\norder of the streams as detected by libavformat except when a program ID is<br>\nalso specified. In this case it is based on the ordering of the streams in the<br>\nprogram.</li>\n</ul>\n<p><em>stream_type[:additional_stream_specifier]</em></p>\n<ul>\n<li>stream_type is one of following: ’v’ or ’V’ for video, ’a’ for audio, ’s’<br>\nfor subtitle, ’d’ for data, and ’t’ for attachments. ’v’ matches all video<br>\nstreams, ’V’ only matches video streams which are not attached pictures, video<br>\nthumbnails or cover arts. If additional_stream_specifier is used, then<br>\nit matches streams which both have this type and match the<br>\nadditional_stream_specifier. Otherwise, it matches all streams of the<br>\nspecified type.</li>\n</ul>\n<p><em>p:program_id[:additional_stream_specifier]</em></p>\n<ul>\n<li>Matches streams which are in the program with the id program_id. If<br>\nadditional_stream_specifier is used, then it matches streams which both<br>\nare part of the program and match the additional_stream_specifier.</li>\n</ul>\n<p><em>#stream_id or i:stream_id</em></p>\n<ul>\n<li>Match the stream by stream id (e.g. PID in MPEG-TS container).</li>\n</ul>\n<p><em>m:key[:value]</em></p>\n<ul>\n<li>Matches streams with the metadata tag key having the specified value. If<br>\nvalue is not given, matches streams that contain the given tag with any<br>\nvalue.</li>\n</ul>\n<p><em>u</em></p>\n<ul>\n<li>\n<p>Matches streams with usable configuration, the codec must be defined and the<br>\nessential information such as video dimension or audio sample rate must be present.</p>\n</li>\n<li>\n<p>Note that in <code>ffmpeg</code>, matching by metadata will only work properly for<br>\ninput files.</p>\n</li>\n</ul>\n<h3>5.2 Generic options</h3>\n<p>These options are shared amongst the ff* tools.</p>\n<p>-L</p>\n<ul>\n<li>Show license.</li>\n</ul>\n<p>-h, -?, -help, --help [arg]</p>\n<ul>\n<li>\n<p>Show help. An optional parameter may be specified to print help about a specific<br>\nitem. If no argument is specified, only basic (non advanced) tool<br>\noptions are shown.</p>\n</li>\n<li>\n<p>Possible values of arg are:</p>\n<ul>\n<li>long\n<ul>\n<li>Print advanced tool options in addition to the basic tool options.</li>\n</ul>\n</li>\n<li>full\n<ul>\n<li>Print complete list of options, including shared and private options<br>\nfor encoders, decoders, demuxers, muxers, filters, etc.</li>\n</ul>\n</li>\n<li>decoder=decoder_name\n<ul>\n<li>Print detailed information about the decoder named decoder_name. Use the<br>\n[-decoders] option to get a list of all decoders.</li>\n</ul>\n</li>\n<li>encoder=encoder_name\n<ul>\n<li>Print detailed information about the encoder named encoder_name. Use the<br>\n[-encoders] option to get a list of all encoders.</li>\n</ul>\n</li>\n<li>demuxer=demuxer_name\n<ul>\n<li>Print detailed information about the demuxer named demuxer_name. Use the<br>\n[-formats] option to get a list of all demuxers and muxers.</li>\n</ul>\n</li>\n<li>muxer=muxer_name\n<ul>\n<li>Print detailed information about the muxer named muxer_name. Use the<br>\n[-formats] option to get a list of all muxers and demuxers.</li>\n</ul>\n</li>\n<li>filter=filter_name\n<ul>\n<li>Print detailed information about the filter named filter_name. Use the<br>\n[-filters] option to get a list of all filters.</li>\n</ul>\n</li>\n<li>bsf=bitstream_filter_name\n<ul>\n<li>Print detailed information about the bitstream filter named bitstream_filter_name.<br>\nUse the [-bsfs] option to get a list of all bitstream filters.</li>\n</ul>\n</li>\n<li>protocol=protocol_name\n<ul>\n<li>Print detailed information about the protocol named protocol_name.<br>\nUse the [-protocols] option to get a list of all protocols.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>-version</p>\n<ul>\n<li>Show version.</li>\n</ul>\n<p>-buildconf</p>\n<ul>\n<li>Show the build configuration, one option per line.</li>\n</ul>\n<p>-formats</p>\n<ul>\n<li>Show available formats (including devices).</li>\n</ul>\n<p>-demuxers</p>\n<ul>\n<li>Show available demuxers.</li>\n</ul>\n<p>-muxers</p>\n<ul>\n<li>Show available muxers.</li>\n</ul>\n<p>-devices</p>\n<ul>\n<li>Show available devices.</li>\n</ul>\n<p>-codecs</p>\n<ul>\n<li>\n<p>Show all codecs known to libavcodec.</p>\n</li>\n<li>\n<p>Note that the term ’codec’ is used throughout this documentation as a shortcut for what is more correctly called a media bitstream format.</p>\n</li>\n</ul>\n<p>-decoders</p>\n<ul>\n<li>Show available decoders.</li>\n</ul>\n<p>-encoders</p>\n<ul>\n<li>Show all available encoders.</li>\n</ul>\n<p>-bsfs</p>\n<ul>\n<li>Show available bitstream filters.</li>\n</ul>\n<p>-protocols</p>\n<ul>\n<li>Show available protocols.</li>\n</ul>\n<p>-filters</p>\n<ul>\n<li>Show available libavfilter filters.</li>\n</ul>\n<p>-pix_fmts</p>\n<ul>\n<li>Show available pixel formats.</li>\n</ul>\n<p>-sample_fmts</p>\n<ul>\n<li>Show available sample formats.</li>\n</ul>\n<p>-layouts</p>\n<ul>\n<li>Show channel names and standard channel layouts.</li>\n</ul>\n<p>-dispositions</p>\n<ul>\n<li>Show stream dispositions.</li>\n</ul>\n<p>-colors</p>\n<ul>\n<li>Show recognized color names.</li>\n</ul>\n<p>-sources <em>device[,opt1=val1[,opt2=val2]...]</em></p>\n<ul>\n<li>Show autodetected sources of the input device. Some devices may provide system-dependent source names that cannot be autodetected. The returned list cannot be assumed to be always complete.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -sources pulse,server=192.168.0.4\n</code></pre>\n<p>-sinks device[,opt1=val1[,opt2=val2]...]</p>\n<ul>\n<li>Show autodetected sinks of the output device. Some devices may provide system-dependent sink names that cannot be autodetected. The returned list cannot be assumed to be always complete.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -sinks pulse,server=192.168.0.4\n</code></pre>\n<p>-loglevel [flags+]loglevel | -v [flags+]loglevel</p>\n<ul>\n<li>\n<p>Set logging level and flags used by the library.</p>\n</li>\n<li>\n<p>The optional flags prefix can consist of the following values:</p>\n</li>\n</ul>\n<p>‘repeat’</p>\n<ul>\n<li>Indicates that repeated log output should not be compressed to the first line and the &quot;Last message repeated n times&quot; line will be omitted.</li>\n</ul>\n<p>‘level’</p>\n<ul>\n<li>Indicates that log output should add a [level] prefix to each message line. This can be used as an alternative to log coloring, e.g. when dumping the log to file.</li>\n</ul>\n<p>Flags can also be used alone by adding a ’+’/’-’ prefix to set/reset a single flag without affecting other flags or changing loglevel. When setting both flags and loglevel, a ’+’ separator is expected between the last flags value and before loglevel.</p>\n<p>loglevel is a string or a number containing one of the following values:</p>\n<p>‘quiet, -8’</p>\n<ul>\n<li>Show nothing at all; be silent.</li>\n</ul>\n<p>‘panic, 0’</p>\n<ul>\n<li>Only show fatal errors which could lead the process to crash, such as an assertion failure. This is not currently used for anything.</li>\n</ul>\n<p>‘fatal, 8’</p>\n<ul>\n<li>Only show fatal errors. These are errors after which the process absolutely cannot continue.</li>\n</ul>\n<p>‘error, 16’</p>\n<ul>\n<li>Show all errors, including ones which can be recovered from.</li>\n</ul>\n<p>‘warning, 24’</p>\n<ul>\n<li>Show all warnings and errors. Any message related to possibly incorrect or unexpected events will be shown.</li>\n</ul>\n<p>‘info, 32’</p>\n<ul>\n<li>Show informative messages during processing. This is in addition to warnings and errors. This is the default value.</li>\n</ul>\n<p>‘verbose, 40’</p>\n<ul>\n<li>Same as info, except more verbose.</li>\n</ul>\n<p>‘debug, 48’</p>\n<ul>\n<li>Show everything, including debugging information.</li>\n</ul>\n<p>‘trace, 56’</p>\n<p>For example to enable repeated log output, add the <code>level</code> prefix, and set<br>\nloglevel to <code>verbose</code>:</p>\n<pre><code class=\"language-shell\">ffmpeg -loglevel repeat+level+verbose -i input output\n</code></pre>\n<p>Another example that enables repeated log output without affecting current<br>\nstate of <code>level</code> prefix flag or loglevel:</p>\n<pre><code class=\"language-shell\">ffmpeg [...] -loglevel +repeat\n</code></pre>\n<p>By default the program logs to stderr. If coloring is supported by the<br>\nterminal, colors are used to mark errors and warnings. Log coloring<br>\ncan be disabled setting the environment variable<br>\n<code>AV_LOG_FORCE_NOCOLOR</code>, or can be forced setting<br>\nthe environment variable <code>AV_LOG_FORCE_COLOR</code>.</p>\n<p>-report</p>\n<ul>\n<li>\n<p>Dump full command line and log output to a file named<br>\n<code>program-YYYYMMDD-HHMMSS.log</code> in the current<br>\ndirectory.<br>\nThis file can be useful for bug reports.<br>\nIt also implies <code>-loglevel debug</code>.</p>\n</li>\n<li>\n<p>Setting the environment variable <code>FFREPORT</code> to any value has the<br>\nsame effect. If the value is a ’:’-separated key=value sequence, these<br>\noptions will affect the report; option values must be escaped if they<br>\ncontain special characters or the options delimiter ’:’ (see the<br>\n“Quoting and escaping” section in the ffmpeg-utils manual).</p>\n</li>\n<li>\n<p>The following options are recognized:</p>\n<ul>\n<li>\n<p>-file</p>\n<ul>\n<li>set the file name to use for the report; <code>%p</code> is expanded to the name<br>\nof the program, <code>%t</code> is expanded to a timestamp, <code>%%</code> is expanded<br>\nto a plain <code>%</code></li>\n</ul>\n</li>\n<li>\n<p>-level</p>\n<ul>\n<li>set the log verbosity level using a numerical value (see <code>-loglevel</code>).</li>\n</ul>\n</li>\n<li>\n<p>For example, to output a report to a file named [ffreport.log]<br>\nusing a log level of <code>32</code> (alias for log level <code>info</code>):</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-shell\">FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output\n</code></pre>\n<ul>\n<li>Errors in parsing the environment variable are not fatal, and will not<br>\nappear in the report.</li>\n</ul>\n<p>-hide_banner</p>\n<ul>\n<li>\n<p>Suppress printing banner.</p>\n</li>\n<li>\n<p>All FFmpeg tools will normally show a copyright notice, build options<br>\nand library versions. This option can be used to suppress printing<br>\nthis information.</p>\n</li>\n</ul>\n<p>-cpuflags flags (global)</p>\n<ul>\n<li>Allows setting and clearing cpu flags. This option is intended<br>\nfor testing. Do not use it unless you know what you’re doing.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -cpuflags -sse+mmx ...\nffmpeg -cpuflags mmx ...\nffmpeg -cpuflags 0 ...\n</code></pre>\n<ul>\n<li>Possible flags for this option are:</li>\n</ul>\n<pre><code class=\"language-text\">‘x86’\n    ‘mmx’\n    ‘mmxext’\n    ‘sse’\n    ‘sse2’\n    ‘sse2slow’\n    ‘sse3’\n    ‘sse3slow’\n    ‘ssse3’\n    ‘atom’\n    ‘sse4.1’\n    ‘sse4.2’\n    ‘avx’\n    ‘avx2’\n    ‘xop’\n    ‘fma3’\n    ‘fma4’\n    ‘3dnow’\n    ‘3dnowext’\n    ‘bmi1’\n    ‘bmi2’\n    ‘cmov’\n‘ARM’\n    ‘armv5te’\n    ‘armv6’\n    ‘armv6t2’\n    ‘vfp’\n    ‘vfpv3’\n    ‘neon’\n    ‘setend’\n‘AArch64’\n    ‘armv8’\n    ‘vfp’\n    ‘neon’\n‘PowerPC’\n  ‘altivec’ \n‘Specific Processors’\n    ‘pentium2’\n    ‘pentium3’\n    ‘pentium4’\n    ‘k6’\n    ‘k62’\n    ‘athlon’\n    ‘athlonxp’\n    ‘k8’\n</code></pre>\n<p>-cpucount count (<em>global</em>)</p>\n<ul>\n<li>Override detection of CPU count. This option is intended<br>\nfor testing. Do not use it unless you know what you’re doing.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -cpucount 2\n</code></pre>\n<p>-max_alloc bytes</p>\n<ul>\n<li>Set the maximum size limit for allocating a block on the heap by ffmpeg’s<br>\nfamily of malloc functions. Exercise <strong>extreme caution</strong> when using<br>\nthis option. Don’t use if you do not understand the full consequence of doing so.<br>\nDefault is INT_MAX.</li>\n</ul>\n<h3>5.3 AVOptions</h3>\n<p>These options are provided directly by the libavformat, libavdevice and<br>\nlibavcodec libraries. To see the list of available AVOptions, use the<br>\n[-help] option. They are separated into two categories:</p>\n<p>generic</p>\n<ul>\n<li>These options can be set for any container, codec or device. Generic options are listed under AVFormatContext options for containers/devices and under AVCodecContext options for codecs.</li>\n</ul>\n<p>private</p>\n<ul>\n<li>These options are specific to the given container, device or codec. Private options are listed under their corresponding containers/devices/codecs.</li>\n</ul>\n<p>For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the id3v2_version private option of the MP3 muxer:</p>\n<pre><code class=\"language-shell\">ffmpeg -i input.flac -id3v2_version 3 out.mp3\n</code></pre>\n<p>All codec AVOptions are per-stream, and thus a stream specifier<br>\nshould be attached to them:</p>\n<pre><code class=\"language-shell\">ffmpeg -i multichannel.mxf -map 0:v:0 -map 0:a:0 -map 0:a:0 -c:a:0 ac3 -b:a:0 640k -ac:a:1 2 -c:a:1 aac -b:2 128k out.mp4\n</code></pre>\n<p>In the above example, a multichannel audio stream is mapped twice for output.<br>\nThe first instance is encoded with codec ac3 and bitrate 640k.<br>\nThe second instance is downmixed to 2 channels and encoded with codec aac. A bitrate of 128k is specified<br>\nfor it using absolute index of the output stream.</p>\n<p>Note: the [-nooption] syntax cannot be used for boolean AVOptions, use [-option 0]/[-option 1].</p>\n<p>Note: the old undocumented way of specifying per-stream AVOptions by<br>\nprepending v/a/s to the options name is now obsolete and will be<br>\nremoved soon.</p>\n<h3>5.4 Main options</h3>\n<p>-f fmt (input/output)</p>\n<ul>\n<li>Force input or output file format. The format is normally auto detected for input files and guessed from the file extension for output files, so this option is not needed in most cases.</li>\n</ul>\n<p>-i url (input)</p>\n<ul>\n<li>input file url</li>\n</ul>\n<p>-y (global)</p>\n<ul>\n<li>Overwrite output files without asking.</li>\n</ul>\n<p>-n (global)</p>\n<ul>\n<li>Do not overwrite output files, and exit immediately if a specified output file already exists.</li>\n</ul>\n<p>-stream_loop number (input)</p>\n<ul>\n<li>Set number of times input stream shall be looped. Loop 0 means no loop, loop -1 means infinite loop.</li>\n</ul>\n<p>-recast_media (global)</p>\n<ul>\n<li>Allow forcing a decoder of a different media type than the one detected or designated by the demuxer. Useful for decoding media data muxed as data streams.</li>\n</ul>\n<p>-c[:stream_specifier] codec (input/output,per-stream)</p>\n<p>-codec[:stream_specifier] codec (input/output,per-stream)</p>\n<ul>\n<li>\n<p>Select an encoder (when used before an output file) or a decoder (when used before an input file) for one or more streams. codec is the name of a decoder/encoder or a special value copy (output only) to indicate that the stream is not to be re-encoded.</p>\n</li>\n<li>\n<p>For example</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT\n</code></pre>\n<ul>\n<li>\n<p>encodes all video streams with libx264 and copies all audio streams.</p>\n</li>\n<li>\n<p>For each stream, the last matching <code>c</code> option is applied, so</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT\n</code></pre>\n<ul>\n<li>will copy all the streams except the second video, which will be encoded with<br>\nlibx264, and the 138th audio, which will be encoded with libvorbis.</li>\n</ul>\n<p>-t duration (input/output)</p>\n<ul>\n<li>\n<p>When used as an input option (before -i), limit the duration of data read from the input file.</p>\n</li>\n<li>\n<p>When used as an output option (before an output url), stop writing the output after its duration reaches duration.</p>\n</li>\n<li>\n<p>duration must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.</p>\n</li>\n<li>\n<p>-to and -t are mutually exclusive and -t has priority.</p>\n</li>\n</ul>\n<p>-to position (input/output)</p>\n<ul>\n<li>\n<p>Stop writing the output or reading the input at position. position must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.</p>\n</li>\n<li>\n<p>-to and -t are mutually exclusive and -t has priority.</p>\n</li>\n</ul>\n<p>-fs limit_size (output)</p>\n<ul>\n<li>Set the file size limit, expressed in bytes. No further chunk of bytes is written after the limit is exceeded. The size of the output file is slightly more than the requested file size.</li>\n</ul>\n<p>-ss position (input/output)</p>\n<ul>\n<li>\n<p>When used as an input option (before -i), seeks in this input file to position. Note that in most formats it is not possible to seek exactly, so ffmpeg will seek to the closest seek point before position. When transcoding and -accurate_seek is enabled (the default), this extra segment between the seek point and position will be decoded and discarded. When doing stream copy or when -noaccurate_seek is used, it will be preserved.</p>\n</li>\n<li>\n<p>When used as an output option (before an output url), decodes but discards input until the timestamps reach position.</p>\n</li>\n<li>\n<p>position must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.</p>\n</li>\n</ul>\n<p>-sseof position (input)</p>\n<ul>\n<li>Like the -ss option but relative to the &quot;end of file&quot;. That is negative values are earlier in the file, 0 is at EOF.</li>\n</ul>\n<p>-itsoffset offset (input)</p>\n<ul>\n<li>\n<p>Set the input time offset.</p>\n</li>\n<li>\n<p>offset must be a time duration specification, see (ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual.</p>\n</li>\n<li>\n<p>The offset is added to the timestamps of the input files. Specifying a positive offset means that the corresponding streams are delayed by the time duration specified in offset.</p>\n</li>\n</ul>\n<p>-itsscale scale (input,per-stream)</p>\n<ul>\n<li>Rescale input timestamps. scale should be a floating point number.</li>\n</ul>\n<p>-timestamp date (output)</p>\n<ul>\n<li>\n<p>Set the recording timestamp in the container.</p>\n</li>\n<li>\n<p>date must be a date specification, see (ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual.</p>\n</li>\n</ul>\n<p>-metadata[:metadata_specifier] key=value (output,per-metadata)</p>\n<ul>\n<li>\n<p>Set a metadata key/value pair.</p>\n</li>\n<li>\n<p>An optional metadata_specifier may be given to set metadata on streams, chapters or programs. See -map_metadata documentation for details.</p>\n</li>\n<li>\n<p>This option overrides metadata set with -map_metadata. It is also possible to delete metadata by using an empty value.</p>\n</li>\n<li>\n<p>For example, for setting the title in the output file:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.avi -metadata out.flv\n</code></pre>\n<ul>\n<li>To set the language of the first audio stream:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT\n</code></pre>\n<p>-disposition[:stream_specifier] value (output,per-stream)</p>\n<ul>\n<li>\n<p>Sets the disposition for a stream.</p>\n</li>\n<li>\n<p>By default, the disposition is copied from the input stream, unless the output stream this option applies to is fed by a complex filtergraph - in that case the disposition is unset by default.</p>\n</li>\n<li>\n<p>value is a sequence of items separated by ’+’ or ’-’. The first item may also be prefixed with ’+’ or ’-’, in which case this option modifies the default value. Otherwise (the first item is not prefixed) this options overrides the default value. A ’+’ prefix adds the given disposition, ’-’ removes it. It is also possible to clear the disposition by setting it to 0.</p>\n</li>\n<li>\n<p>If no -disposition options were specified for an output file, ffmpeg will automatically set the ’default’ disposition on the first stream of each type, when there are multiple streams of this type in the output file and no stream of that type is already marked as default.</p>\n</li>\n<li>\n<p>The -dispositions option lists the known dispositions.</p>\n</li>\n<li>\n<p>For example, to make the second audio stream the default stream:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.mkv -c copy -disposition:a:1 default out.mkv\n</code></pre>\n<ul>\n<li>To make the second subtitle stream the default stream and remove the default<br>\ndisposition from the first subtitle stream:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.mkv -c copy -disposition:s:0 0 -disposition:s:1 default out.mkv\n</code></pre>\n<ul>\n<li>To add an embedded cover/thumbnail:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.mp4 -i IMAGE -map 0 -map 1 -c copy -c:v:1 png -disposition:v:1 attached_pic out.mp4\n</code></pre>\n<ul>\n<li>Not all muxers support embedded thumbnails, and those who do, only support a few formats, like JPEG<br>\nor PNG.</li>\n</ul>\n<p>-program [title=title:][program_num=program_num:]st=stream[:st=stream...] (output)</p>\n<ul>\n<li>Creates a program with the specified title, program_num and adds the specified stream(s) to it.</li>\n</ul>\n<p>-target type (output)</p>\n<ul>\n<li>Specify target file type (vcd, svcd, dvd, dv, dv50). type may be prefixed with pal-, ntsc- or film- to use the corresponding standard. All the format options (bitrate, codecs, buffer sizes) are then set automatically. You can just type:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg\n</code></pre>\n<ul>\n<li>Nevertheless you can specify additional options as long as you know<br>\nthey do not conflict with the standard, as in:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg\n</code></pre>\n<ul>\n<li>The parameters set for each target are as follows.</li>\n</ul>\n<p><strong>VCD</strong></p>\n<pre><code class=\"language-shell\">pal:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x288 -r 25\n-codec:v mpeg1video -g 15 -b:v 1150k -maxrate:v 1150v -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n\nntsc:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x240 -r 30000/1001\n-codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150v -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n\nfilm:\n-f vcd -muxrate 1411200 -muxpreload 0.44 -packetsize 2324\n-s 352x240 -r 24000/1001\n-codec:v mpeg1video -g 18 -b:v 1150k -maxrate:v 1150v -minrate:v 1150k -bufsize:v 327680\n-ar 44100 -ac 2\n-codec:a mp2 -b:a 224k\n</code></pre>\n<p><strong>SVCD</strong></p>\n<pre><code class=\"language-shell\">pal:\n-f svcd -packetsize 2324\n-s 480x576 -pix_fmt yuv420p -r 25\n-codec:v mpeg2video -g 15 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n\nntsc:\n-f svcd -packetsize 2324\n-s 480x480 -pix_fmt yuv420p -r 30000/1001\n-codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n\nfilm:\n-f svcd -packetsize 2324\n-s 480x480 -pix_fmt yuv420p -r 24000/1001\n-codec:v mpeg2video -g 18 -b:v 2040k -maxrate:v 2516k -minrate:v 0 -bufsize:v 1835008 -scan_offset 1\n-ar 44100\n-codec:a mp2 -b:a 224k\n</code></pre>\n<p><strong>DVD</strong></p>\n<pre><code class=\"language-shell\">pal:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x576 -pix_fmt yuv420p -r 25\n-codec:v mpeg2video -g 15 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n\nntsc:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x480 -pix_fmt yuv420p -r 30000/1001\n-codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n\nfilm:\n-f dvd -muxrate 10080k -packetsize 2048\n-s 720x480 -pix_fmt yuv420p -r 24000/1001\n-codec:v mpeg2video -g 18 -b:v 6000k -maxrate:v 9000k -minrate:v 0 -bufsize:v 1835008\n-ar 48000\n-codec:a ac3 -b:a 448k\n</code></pre>\n<p><strong>DV</strong></p>\n<pre><code class=\"language-shell\">pal:\n-f dv\n-s 720x576 -pix_fmt yuv420p -r 25\n-ar 48000 -ac 2\n\nntsc:\n-f dv\n-s 720x480 -pix_fmt yuv411p -r 30000/1001\n-ar 48000 -ac 2\n\nfilm:\n-f dv\n-s 720x480 -pix_fmt yuv411p -r 24000/1001\n-ar 48000 -ac 2\n</code></pre>\n<ul>\n<li>\n<p>The <code>dv50</code> target is identical to the <code>dv</code> target except that the pixel format<br>\nset is <code>yuv422p</code> for all three standards.</p>\n</li>\n<li>\n<p>Any user-set value for a parameter above will override the target preset value. In that case, the<br>\noutput may<br>\nnot comply with the target standard.</p>\n</li>\n</ul>\n<p>-dn (input/output)</p>\n<ul>\n<li>\n<p>As an input option, blocks all data streams of a file from being filtered or being automatically selected or mapped for any output. See -discard option to disable streams individually.</p>\n</li>\n<li>\n<p>As an output option, disables data recording i.e. automatic selection or mapping of any data stream. For full manual control see the -map option.</p>\n</li>\n</ul>\n<p>-dframes number (output)</p>\n<ul>\n<li>Set the number of data frames to output. This is an obsolete alias for -frames:d, which you should use instead.</li>\n</ul>\n<p>-frames[:stream_specifier] framecount (output,per-stream)</p>\n<ul>\n<li>Stop writing to the stream after framecount frames.</li>\n</ul>\n<p>-q[:stream_specifier] q (output,per-stream)</p>\n<p>-qscale[:stream_specifier] q (output,per-stream)</p>\n<ul>\n<li>Use fixed quality scale (VBR). The meaning of q/qscale is codec-dependent. If qscale is used without a stream_specifier then it applies only to the video stream, this is to maintain compatibility with previous behavior and as specifying the same codec specific value to 2 different codecs that is audio and video generally is not what is intended when no stream_specifier is used.</li>\n</ul>\n<p>-filter[:stream_specifier] filtergraph (output,per-stream)</p>\n<ul>\n<li>\n<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>\n</li>\n<li>\n<p>filtergraph is a description of the filtergraph to apply to the stream, and must have a single input and a single output of the same type of the stream. In the filtergraph, the input is associated to the label in, and the output to the label out. See the ffmpeg-filters manual for more information about the filtergraph syntax.</p>\n</li>\n<li>\n<p>See the -filter_complex option if you want to create filtergraphs with multiple inputs and/or outputs.</p>\n</li>\n</ul>\n<p>-filter_script[:stream_specifier] filename (output,per-stream)</p>\n<ul>\n<li>This option is similar to -filter, the only difference is that its argument is the name of the file from which a filtergraph description is to be read.</li>\n</ul>\n<p>-reinit_filter[:stream_specifier] integer (input,per-stream)</p>\n<ul>\n<li>This boolean option determines if the filtergraph(s) to which this stream is fed gets reinitialized when input frame parameters change mid-stream. This option is enabled by default as most video and all audio filters cannot handle deviation in input frame properties. Upon reinitialization, existing filter state is lost, like e.g. the frame count n reference available in some filters. Any frames buffered at time of reinitialization are lost. The properties where a change triggers reinitialization are, for video, frame resolution or pixel format; for audio, sample format, sample rate, channel count or channel layout.</li>\n</ul>\n<p>-filter_threads nb_threads (global)</p>\n<ul>\n<li>Defines how many threads are used to process a filter pipeline. Each pipeline will produce a thread pool with this many threads available for parallel processing. The default is the number of available CPUs.</li>\n</ul>\n<p>-pre[:stream_specifier] preset_name (output,per-stream)</p>\n<ul>\n<li>Specify the preset for matching stream(s).</li>\n</ul>\n<p>-stats (global)</p>\n<ul>\n<li>Print encoding progress/statistics. It is on by default, to explicitly disable it you need to specify -nostats.</li>\n</ul>\n<p>-stats_period time (global)</p>\n<ul>\n<li>Set period at which encoding progress/statistics are updated. Default is 0.5 seconds.</li>\n</ul>\n<p>-progress url (global)</p>\n<ul>\n<li>\n<p>Send program-friendly progress information to url.</p>\n</li>\n<li>\n<p>Progress information is written periodically and at the end of the encoding process. It is made of &quot;key=value&quot; lines. key consists of only alphanumeric characters. The last key of a sequence of progress information is always &quot;progress&quot;.</p>\n</li>\n<li>\n<p>The update period is set using -stats_period.</p>\n</li>\n</ul>\n<p>-stdin</p>\n<ul>\n<li>\n<p>Enable interaction on standard input. On by default unless standard input is used as an input. To explicitly disable interaction you need to specify -nostdin.</p>\n</li>\n<li>\n<p>Disabling interaction on standard input is useful, for example, if ffmpeg is in the background process group. Roughly the same result can be achieved with ffmpeg ... &lt; /dev/null but it requires a shell.</p>\n</li>\n</ul>\n<p>-debug_ts (global)</p>\n<ul>\n<li>\n<p>Print timestamp information. It is off by default. This option is mostly useful for testing and debugging purposes, and the output format may change from one version to another, so it should not be employed by portable scripts.</p>\n</li>\n<li>\n<p>See also the option -fdebug ts.</p>\n</li>\n</ul>\n<p>-attach filename (output)</p>\n<ul>\n<li>\n<p>Add an attachment to the output file. This is supported by a few formats like Matroska for e.g. fonts used in rendering subtitles. Attachments are implemented as a specific type of stream, so this option will add a new stream to the file. It is then possible to use per-stream options on this stream in the usual way. Attachment streams created with this option will be created after all the other streams (i.e. those created with -map or automatic mappings).</p>\n</li>\n<li>\n<p>Note that for Matroska you also have to set the mimetype metadata tag:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -attach DejaVuSans.ttf -metadata:s:2 mimetype=application/x-truetype-font out.mkv\n</code></pre>\n<ul>\n<li>(assuming that the attachment stream will be third in the output file).</li>\n</ul>\n<p>-dump_attachment[:stream_specifier] filename (input,per-stream)</p>\n<ul>\n<li>\n<p>Extract the matching attachment stream into a file named filename. If filename is empty, then the value of the filename metadata tag will be used.</p>\n</li>\n<li>\n<p>E.g. to extract the first attachment to a file named ’out.ttf’:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -dump_attachment:t:0 out.ttf -i INPUT\n</code></pre>\n<ul>\n<li>To extract all attachments to files determined by the <code>filename</code> tag:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -dump_attachment:t &quot;&quot; -i INPUT\n</code></pre>\n<ul>\n<li>Technical note – attachments are implemented as codec extradata, so this<br>\noption can actually be used to extract extradata from any stream, not just<br>\nattachments.</li>\n</ul>\n<h3>5.5 Video Options</h3>\n<p>-vframes number (output)</p>\n<ul>\n<li>Set the number of video frames to output. This is an obsolete alias for -frames:v, which you should use instead.</li>\n</ul>\n<p>-r[:stream_specifier] fps (input/output,per-stream)</p>\n<ul>\n<li>\n<p>Set frame rate (Hz value, fraction or abbreviation).</p>\n</li>\n<li>\n<p>As an input option, ignore any timestamps stored in the file and instead generate timestamps assuming constant frame rate fps. This is not the same as the -framerate option used for some input formats like image2 or v4l2 (it used to be the same in older versions of FFmpeg). If in doubt use -framerate instead of the input option -r.</p>\n</li>\n<li>\n<p>As an output option, duplicate or drop input frames to achieve constant output frame rate fps.</p>\n</li>\n</ul>\n<p>-fpsmax[:stream_specifier] fps (output,per-stream)</p>\n<ul>\n<li>\n<p>Set maximum frame rate (Hz value, fraction or abbreviation).</p>\n</li>\n<li>\n<p>Clamps output frame rate when output framerate is auto-set and is higher than this value. Useful in batch processing or when input framerate is wrongly detected as very high. It cannot be set together with -r. It is ignored during streamcopy.</p>\n</li>\n</ul>\n<p>-s[:stream_specifier] size (input/output,per-stream)</p>\n<ul>\n<li>\n<p>Set frame size.</p>\n</li>\n<li>\n<p>As an input option, this is a shortcut for the video_size private option, recognized by some demuxers for which the frame size is either not stored in the file or is configurable – e.g. raw video or video grabbers.</p>\n</li>\n<li>\n<p>As an output option, this inserts the scale video filter to the end of the corresponding filtergraph. Please use the scale filter directly to insert it at the beginning or some other place.</p>\n</li>\n<li>\n<p>The format is ‘wxh’ (default - same as source).</p>\n</li>\n</ul>\n<p>-aspect[:stream_specifier] aspect (output,per-stream)</p>\n<ul>\n<li>\n<p>Set the video display aspect ratio specified by aspect.</p>\n</li>\n<li>\n<p>aspect can be a floating point number string, or a string of the form num:den, where num and den are the numerator and denominator of the aspect ratio. For example &quot;4:3&quot;, &quot;16:9&quot;, &quot;1.3333&quot;, and &quot;1.7777&quot; are valid argument values.</p>\n</li>\n<li>\n<p>If used together with -vcodec copy, it will affect the aspect ratio stored at container level, but not the aspect ratio stored in encoded frames, if it exists.</p>\n</li>\n</ul>\n<p>-vn (input/output)</p>\n<ul>\n<li>\n<p>As an input option, blocks all video streams of a file from being filtered or being automatically selected or mapped for any output. See -discard option to disable streams individually.</p>\n</li>\n<li>\n<p>As an output option, disables video recording i.e. automatic selection or mapping of any video stream. For full manual control see the -map option.</p>\n</li>\n</ul>\n<p>-vcodec codec (output)</p>\n<ul>\n<li>Set the video codec. This is an alias for -codec:v.</li>\n</ul>\n<p>-pass[:stream_specifier] n (output,per-stream)</p>\n<ul>\n<li>Select the pass number (1 or 2). It is used to do two-pass video encoding. The statistics of the video are recorded in the first pass into a log file (see also the option -passlogfile), and in the second pass that log file is used to generate the video at the exact requested bitrate. On pass 1, you may just deactivate audio and set output to null, examples for Windows and Unix:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y NUL\nffmpeg -i foo.mov -c:v libxvid -pass 1 -an -f rawvideo -y /dev/null\n</code></pre>\n<p>-passlogfile[:stream_specifier] prefix (output,per-stream)</p>\n<ul>\n<li>Set two-pass log file name prefix to prefix, the default file name prefix is “ffmpeg2pass”. The complete file name will be PREFIX-N.log, where N is a number specific to the output stream</li>\n</ul>\n<p>-vf filtergraph (output)</p>\n<ul>\n<li>\n<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>\n</li>\n<li>\n<p>This is an alias for -filter:v, see the -filter option.</p>\n</li>\n</ul>\n<p>-autorotate</p>\n<ul>\n<li>Automatically rotate the video according to file metadata. Enabled by default, use -noautorotate to disable it.</li>\n</ul>\n<p>-autoscale</p>\n<ul>\n<li>Automatically scale the video according to the resolution of first frame. Enabled by default, use -noautoscale to disable it. When autoscale is disabled, all output frames of filter graph might not be in the same resolution and may be inadequate for some encoder/muxer. Therefore, it is not recommended to disable it unless you really know what you are doing. Disable autoscale at your own risk.</li>\n</ul>\n<h3>5.6 Advanced Video options</h3>\n<p>-pix_fmt[:stream_specifier] format (input/output,per-stream)</p>\n<ul>\n<li>Set pixel format. Use -pix_fmts to show all the supported pixel formats. If the selected pixel format can not be selected, ffmpeg will print a warning and select the best pixel format supported by the encoder. If pix_fmt is prefixed by a +, ffmpeg will exit with an error if the requested pixel format can not be selected, and automatic conversions inside filtergraphs are disabled. If pix_fmt is a single +, ffmpeg selects the same pixel format as the input (or graph output) and automatic conversions are disabled.</li>\n</ul>\n<p>-sws_flags flags (input/output)</p>\n<ul>\n<li>Set SwScaler flags.</li>\n</ul>\n<p>-rc_override[:stream_specifier] override (output,per-stream)</p>\n<ul>\n<li>Rate control override for specific intervals, formatted as &quot;int,int,int&quot; list separated with slashes. Two first values are the beginning and end frame numbers, last one is quantizer to use if positive, or quality factor if negative.</li>\n</ul>\n<p>-ilme</p>\n<ul>\n<li>Force interlacing support in encoder (MPEG-2 and MPEG-4 only). Use this option if your input file is interlaced and you want to keep the interlaced format for minimum losses. The alternative is to deinterlace the input stream by use of a filter such as yadif or bwdif, but deinterlacing introduces losses.</li>\n</ul>\n<p>-psnr</p>\n<ul>\n<li>Calculate PSNR of compressed frames.</li>\n</ul>\n<p>-vstats</p>\n<ul>\n<li>Dump video coding statistics to vstats_HHMMSS.log.</li>\n</ul>\n<p>-vstats_file file</p>\n<ul>\n<li>Dump video coding statistics to file.</li>\n</ul>\n<p>-vstats_version file</p>\n<ul>\n<li>\n<p>Specifies which version of the vstats format to use. Default is 2.</p>\n</li>\n<li>\n<p>version = 1 :</p>\n</li>\n<li>\n<p><code>frame= %5d q= %2.1f PSNR= %6.2f f_size= %6d s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s</code></p>\n</li>\n<li>\n<p>version &gt; 1:</p>\n</li>\n<li>\n<p><code>out= %2d st= %2d frame= %5d q= %2.1f PSNR= %6.2f f_size= %6d s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s</code></p>\n</li>\n</ul>\n<p>-top[:stream_specifier] n (output,per-stream)</p>\n<ul>\n<li>top=1/bottom=0/auto=-1 field first</li>\n</ul>\n<p>-dc precision</p>\n<ul>\n<li>Intra_dc_precision.</li>\n</ul>\n<p>-vtag fourcc/tag (output)</p>\n<ul>\n<li>Force video tag/fourcc. This is an alias for -tag:v.</li>\n</ul>\n<p>-qphist (global)</p>\n<ul>\n<li>Show QP histogram</li>\n</ul>\n<p>-vbsf bitstream_filter</p>\n<ul>\n<li>Deprecated see -bsf</li>\n</ul>\n<p>-force_key_frames[:stream_specifier] time[,time...] (output,per-stream)</p>\n<p>-force_key_frames[:stream_specifier] expr:expr (output,per-stream)</p>\n<p>-force_key_frames[:stream_specifier] source (output,per-stream)</p>\n<p>-force_key_frames[:stream_specifier] source_no_drop (output,per-stream)</p>\n<ul>\n<li>\n<p>force_key_frames can take arguments of the following form:</p>\n</li>\n<li>\n<p>time[,time...]</p>\n<ul>\n<li>\n<p>If the argument consists of timestamps, ffmpeg will round the specified times to the nearest output timestamp as per the encoder time base and force a keyframe at the first frame having timestamp equal or greater than the computed timestamp. Note that if the encoder time base is too coarse, then the keyframes may be forced on frames with timestamps lower than the specified time. The default encoder time base is the inverse of the output framerate but may be set otherwise via -enc_time_base.</p>\n</li>\n<li>\n<p>If one of the times is &quot;chapters[delta]&quot;, it is expanded into the time of the beginning of all chapters in the file, shifted by delta, expressed as a time in seconds. This option can be useful to ensure that a seek point is present at a chapter mark or any other designated place in the output file.</p>\n</li>\n<li>\n<p>For example, to insert a key frame at 5 minutes, plus key frames 0.1 second before the beginning of every chapter:</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-shell\">-force_key_frames 0:05:00,chapters-0.1\n</code></pre>\n<ul>\n<li>\n<p>expr:expr</p>\n<ul>\n<li>\n<p>If the argument is prefixed with expr:, the string expr is interpreted like an expression and is evaluated for each frame. A key frame is forced in case the evaluation is non-zero.</p>\n</li>\n<li>\n<p>The expression in expr can contain the following constants:</p>\n</li>\n<li>\n<p>n</p>\n<ul>\n<li>the number of current processed frame, starting from 0</li>\n</ul>\n</li>\n<li>\n<p>n_forced</p>\n<ul>\n<li>the number of forced frames</li>\n</ul>\n</li>\n<li>\n<p>prev_forced_n</p>\n<ul>\n<li>the number of the previous forced frame, it is NAN when no keyframe was forced yet</li>\n</ul>\n</li>\n<li>\n<p>prev_forced_t</p>\n<ul>\n<li>the time of the previous forced frame, it is NAN when no keyframe was forced yet</li>\n</ul>\n</li>\n<li>\n<p>t</p>\n<ul>\n<li>the time of the current processed frame</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>For example to force a key frame every 5 seconds, you can specify:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">-force_key_frames expr:gte(t,n_forced*5)\n</code></pre>\n<ul>\n<li>To force a key frame 5 seconds after the time of the last forced one, starting from second 13:</li>\n</ul>\n<pre><code class=\"language-shell\">-force_key_frames expr:if(isnan(prev_forced_t),gte(t,13),gte(t,prev_forced_t+5))\n</code></pre>\n<ul>\n<li>\n<p>source</p>\n<ul>\n<li>If the argument is source, ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source.</li>\n</ul>\n</li>\n<li>\n<p>source_no_drop</p>\n<ul>\n<li>If the argument is source_no_drop, ffmpeg will force a key frame if the current frame being encoded is marked as a key frame in its source. In cases where this particular source frame has to be dropped, enforce the next available frame to become a key frame instead.</li>\n</ul>\n</li>\n<li>\n<p>Note that forcing too many keyframes is very harmful for the lookahead algorithms of certain encoders: using fixed-GOP options or similar would be more efficient.</p>\n</li>\n</ul>\n<p>-copyinkf[:stream_specifier] (output,per-stream)</p>\n<ul>\n<li>When doing stream copy, copy also non-key frames found at the beginning.</li>\n</ul>\n<p>-init_hw_device type[=name][:device[,key=value...]]</p>\n<ul>\n<li>\n<p>Initialise a new hardware device of type type called name, using the given device parameters. If no name is specified it will receive a default name of the form &quot;type%d&quot;.</p>\n</li>\n<li>\n<p>The meaning of device and the following arguments depends on the device type:</p>\n</li>\n<li>\n<p>cuda</p>\n<ul>\n<li>\n<p>device is the number of the CUDA device.</p>\n</li>\n<li>\n<p>The following options are recognized:</p>\n</li>\n<li>\n<p>primary_ctx</p>\n<ul>\n<li>If set to 1, uses the primary device context instead of creating a new one.</li>\n</ul>\n</li>\n<li>\n<p>Examples:</p>\n</li>\n<li>\n<p>-init_hw_device cuda:1</p>\n<ul>\n<li>Choose the second device on the system.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device cuda:0,primary_ctx=1</p>\n<ul>\n<li>Choose the first device and use the primary device context.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>dxva2</p>\n<ul>\n<li>device is the number of the Direct3D 9 display adapter.</li>\n</ul>\n</li>\n<li>\n<p>d3d11va</p>\n<ul>\n<li>device is the number of the Direct3D 11 display adapter.</li>\n</ul>\n</li>\n<li>\n<p>vaapi</p>\n<ul>\n<li>device is either an X11 display name or a DRM render node. If not specified, it will attempt to open the default X11 display ($DISPLAY) and then the first DRM render node (/dev/dri/renderD128).</li>\n</ul>\n</li>\n<li>\n<p>vdpau</p>\n<ul>\n<li>device is an X11 display name. If not specified, it will attempt to open the default X11 display ($DISPLAY).</li>\n</ul>\n</li>\n<li>\n<p>qsv</p>\n<ul>\n<li>device selects a value in ‘MFX_IMPL_*’. Allowed values are:</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-shell\">auto\nsw\nhw\nauto_any\nhw_any\nhw2\nhw3\nhw4\n</code></pre>\n<ul>\n<li>\n<p>If not specified, ‘auto_any’ is used. (Note that it may be easier to achieve the desired result for QSV by creating the platform-appropriate subdevice (‘dxva2’ or ‘d3d11va’ or ‘vaapi’) and then deriving a QSV device from that.)</p>\n</li>\n<li>\n<p>Alternatively, ‘child_device_type’ helps to choose platform-appropriate subdevice type. On Windows ‘d3d11va’ is used as default subdevice type.</p>\n</li>\n<li>\n<p>Examples:</p>\n</li>\n<li>\n<p>-init_hw_device qsv:hw,child_device_type=d3d11va</p>\n<ul>\n<li>Choose the GPU subdevice with type ‘d3d11va’ and create QSV device with ‘MFX_IMPL_HARDWARE’.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device qsv:hw,child_device_type=dxva2</p>\n<ul>\n<li>Choose the GPU subdevice with type ‘dxva2’ and create QSV device with ‘MFX_IMPL_HARDWARE’.</li>\n</ul>\n</li>\n<li>\n<p>opencl</p>\n<ul>\n<li>\n<p>device selects the platform and device as platform_index.device_index.</p>\n</li>\n<li>\n<p>The set of devices can also be filtered using the key-value pairs to find only devices matching particular platform or device strings.</p>\n</li>\n<li>\n<p>The strings usable as filters are:</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-shell\">platform_profile\nplatform_version\nplatform_name\nplatform_vendor\nplatform_extensions\ndevice_name\ndevice_vendor\ndriver_version\ndevice_version\ndevice_profile\ndevice_extensions\ndevice_type\n</code></pre>\n<ul>\n<li>\n<p>The indices and filters must together uniquely select a device.</p>\n</li>\n<li>\n<p>Examples:</p>\n</li>\n<li>\n<p>-init_hw_device opencl:0.1</p>\n<ul>\n<li>Choose the second device on the first platform.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device opencl:,device_name=Foo9000</p>\n<ul>\n<li>Choose the device with a name containing the string Foo9000.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device opencl:1,device_type=gpu,device_extensions=cl_khr_fp16</p>\n<ul>\n<li>Choose the GPU device on the second platform supporting the cl_khr_fp16 extension.</li>\n</ul>\n</li>\n<li>\n<p>vulkan</p>\n<ul>\n<li>\n<p>If device is an integer, it selects the device by its index in a system-dependent list of devices. If device is any other string, it selects the first device with a name containing that string as a substring.</p>\n</li>\n<li>\n<p>The following options are recognized:</p>\n</li>\n<li>\n<p>debug</p>\n<ul>\n<li>If set to 1, enables the validation layer, if installed.</li>\n</ul>\n</li>\n<li>\n<p>linear_images</p>\n<ul>\n<li>If set to 1, images allocated by the hwcontext will be linear and locally mappable.</li>\n</ul>\n</li>\n<li>\n<p>instance_extensions</p>\n<ul>\n<li>A plus separated list of additional instance extensions to enable.</li>\n</ul>\n</li>\n<li>\n<p>device_extensions</p>\n<ul>\n<li>A plus separated list of additional device extensions to enable.</li>\n</ul>\n</li>\n<li>\n<p>Examples:</p>\n</li>\n<li>\n<p>-init_hw_device vulkan:1</p>\n<ul>\n<li>Choose the second device on the system.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device vulkan:RADV</p>\n<ul>\n<li>Choose the first device with a name containing the string RADV.</li>\n</ul>\n</li>\n<li>\n<p>-init_hw_device vulkan:0,instance_extensions=VK_KHR_wayland_surface+VK_KHR_xcb_surface</p>\n<ul>\n<li>Choose the first device and enable the Wayland and XCB instance extensions.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>-init_hw_device type[=name]@source</p>\n<ul>\n<li>Initialise a new hardware device of type type called name, deriving it from the existing device with the name source.</li>\n</ul>\n<p>-init_hw_device list</p>\n<ul>\n<li>List all hardware device types supported in this build of ffmpeg.</li>\n</ul>\n<p>-filter_hw_device name</p>\n<ul>\n<li>\n<p>Pass the hardware device called name to all filters in any filter graph. This can be used to set the device to upload to with the hwupload filter, or the device to map to with the hwmap filter. Other filters may also make use of this parameter when they require a hardware device. Note that this is typically only required when the input is not already in hardware frames - when it is, filters will derive the device they require from the context of the frames they receive as input.</p>\n</li>\n<li>\n<p>This is a global setting, so all filters will receive the same device.</p>\n</li>\n</ul>\n<p>-hwaccel[:stream_specifier] hwaccel (input,per-stream)</p>\n<ul>\n<li>\n<p>Use hardware acceleration to decode the matching stream(s). The allowed values of hwaccel are:</p>\n</li>\n<li>\n<p>none</p>\n<ul>\n<li>Do not use any hardware acceleration (the default).</li>\n</ul>\n</li>\n<li>\n<p>auto</p>\n<ul>\n<li>Automatically select the hardware acceleration method.</li>\n</ul>\n</li>\n<li>\n<p>vdpau</p>\n<ul>\n<li>Use VDPAU (Video Decode and Presentation API for Unix) hardware acceleration.</li>\n</ul>\n</li>\n<li>\n<p>dxva2</p>\n<ul>\n<li>Use DXVA2 (DirectX Video Acceleration) hardware acceleration.</li>\n</ul>\n</li>\n<li>\n<p>d3d11va</p>\n<ul>\n<li>Use D3D11VA (DirectX Video Acceleration) hardware acceleration.</li>\n</ul>\n</li>\n<li>\n<p>vaapi</p>\n<ul>\n<li>Use VAAPI (Video Acceleration API) hardware acceleration.</li>\n</ul>\n</li>\n<li>\n<p>qsv</p>\n<ul>\n<li>\n<p>Use the Intel QuickSync Video acceleration for video transcoding.</p>\n</li>\n<li>\n<p>Unlike most other values, this option does not enable accelerated decoding (that is used automatically whenever a qsv decoder is selected), but accelerated transcoding, without copying the frames into the system memory.</p>\n</li>\n<li>\n<p>For it to work, both the decoder and the encoder must support QSV acceleration and no filters must be used.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>This option has no effect if the selected hwaccel is not available or not supported by the chosen decoder.</p>\n</li>\n<li>\n<p>Note that most acceleration methods are intended for playback and will not be faster than software decoding on modern CPUs. Additionally, ffmpeg will usually need to copy the decoded frames from the GPU memory into the system memory, resulting in further performance loss. This option is thus mainly useful for testing.</p>\n</li>\n</ul>\n<p>-hwaccel_device[:stream_specifier] hwaccel_device (input,per-stream)</p>\n<ul>\n<li>\n<p>Select a device to use for hardware acceleration.</p>\n</li>\n<li>\n<p>This option only makes sense when the -hwaccel option is also specified. It can either refer to an existing device created with -init_hw_device by name, or it can create a new device as if ‘-init_hw_device’ type:hwaccel_device were called immediately before.</p>\n</li>\n</ul>\n<p>-hwaccels</p>\n<ul>\n<li>List all hardware acceleration components enabled in this build of ffmpeg. Actual runtime availability depends on the hardware and its suitable driver being installed.</li>\n</ul>\n<h3>5.7 Audio Options</h3>\n<p>-aframes number (output)</p>\n<ul>\n<li>Set the number of audio frames to output. This is an obsolete alias for -frames:a, which you should use instead.</li>\n</ul>\n<p>-ar[:stream_specifier] freq (input/output,per-stream)</p>\n<ul>\n<li>Set the audio sampling frequency. For output streams it is set by default to the frequency of the corresponding input stream. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</li>\n</ul>\n<p>-aq q (output)</p>\n<ul>\n<li>Set the audio quality (codec-specific, VBR). This is an alias for -q:a.</li>\n</ul>\n<p>-ac[:stream_specifier] channels (input/output,per-stream)</p>\n<ul>\n<li>Set the number of audio channels. For output streams it is set by default to the number of input audio channels. For input streams this option only makes sense for audio grabbing devices and raw demuxers and is mapped to the corresponding demuxer options.</li>\n</ul>\n<p>-an (input/output)</p>\n<ul>\n<li>\n<p>As an input option, blocks all audio streams of a file from being filtered or being automatically selected or mapped for any output. See -discard option to disable streams individually.</p>\n</li>\n<li>\n<p>As an output option, disables audio recording i.e. automatic selection or mapping of any audio stream. For full manual control see the -map option.</p>\n</li>\n</ul>\n<p>-acodec codec (input/output)</p>\n<ul>\n<li>Set the audio codec. This is an alias for -codec:a.</li>\n</ul>\n<p>-sample_fmt[:stream_specifier] sample_fmt (output,per-stream)</p>\n<ul>\n<li>Set the audio sample format. Use -sample_fmts to get a list of supported sample formats.</li>\n</ul>\n<p>-af filtergraph (output)</p>\n<ul>\n<li>\n<p>Create the filtergraph specified by filtergraph and use it to filter the stream.</p>\n</li>\n<li>\n<p>This is an alias for -filter:a, see the -filter option.</p>\n</li>\n</ul>\n<h3>5.8 Advanced Audio options</h3>\n<p>-atag fourcc/tag (output)</p>\n<ul>\n<li>Force audio tag/fourcc. This is an alias for -tag:a.</li>\n</ul>\n<p>-absf bitstream_filter</p>\n<ul>\n<li>Deprecated, see -bsf</li>\n</ul>\n<p>-guess_layout_max channels (input,per-stream)</p>\n<ul>\n<li>If some input channel layout is not known, try to guess only if it corresponds to at most the specified number of channels. For example, 2 tells to ffmpeg to recognize 1 channel as mono and 2 channels as stereo but not 6 channels as 5.1. The default is to always try to guess. Use 0 to disable all guessing.</li>\n</ul>\n<h3>5.9 Subtitle options</h3>\n<p>-scodec codec (input/output)</p>\n<ul>\n<li>Set the subtitle codec. This is an alias for -codec:s.</li>\n</ul>\n<p>-sn (input/output)</p>\n<ul>\n<li>\n<p>As an input option, blocks all subtitle streams of a file from being filtered or being automatically selected or mapped for any output. See -discard option to disable streams individually.</p>\n</li>\n<li>\n<p>As an output option, disables subtitle recording i.e. automatic selection or mapping of any subtitle stream. For full manual control see the -map option.</p>\n</li>\n</ul>\n<p>-sbsf bitstream_filter</p>\n<ul>\n<li>Deprecated, see -bsf</li>\n</ul>\n<h3>5.10 Advanced Subtitle options</h3>\n<p>-fix_sub_duration</p>\n<ul>\n<li>\n<p>Fix subtitles durations. For each subtitle, wait for the next packet in the same stream and adjust the duration of the first to avoid overlap. This is necessary with some subtitles codecs, especially DVB subtitles, because the duration in the original packet is only a rough estimate and the end is actually marked by an empty subtitle frame. Failing to use this option when necessary can result in exaggerated durations or muxing failures due to non-monotonic timestamps.</p>\n</li>\n<li>\n<p>Note that this option will delay the output of all data until the next subtitle packet is decoded: it may increase memory consumption and latency a lot.</p>\n</li>\n</ul>\n<p>-canvas_size size</p>\n<ul>\n<li>Set the size of the canvas used to render subtitles.</li>\n</ul>\n<h3>5.11 Advanced options</h3>\n<p>-map [-]input_file_id[:stream_specifier][?][,sync_file_id[:stream_specifier]] | [linklabel] (output)</p>\n<ul>\n<li>\n<p>Designate one or more input streams as a source for the output file. Each input stream is identified by the input file index input_file_id and the input stream index input_stream_id within the input file. Both indices start at 0. If specified, sync_file_id:stream_specifier sets which input stream is used as a presentation sync reference.</p>\n</li>\n<li>\n<p>The first -map option on the command line specifies the source for output stream 0, the second -map option specifies the source for output stream 1, etc.</p>\n</li>\n<li>\n<p>A - character before the stream identifier creates a &quot;negative&quot; mapping. It disables matching streams from already created mappings.</p>\n</li>\n<li>\n<p>A trailing ? after the stream index will allow the map to be optional: if the map matches no streams the map will be ignored instead of failing. Note the map will still fail if an invalid input file index is used; such as if the map refers to a non-existent input.</p>\n</li>\n<li>\n<p>An alternative [linklabel] form will map outputs from complex filter graphs (see the -filter_complex option) to the output file. linklabel must correspond to a defined output link label in the graph.</p>\n</li>\n<li>\n<p>For example, to map ALL streams from the first input file to output</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0 output\n</code></pre>\n<ul>\n<li>For example, if you have two audio streams in the first input file, these streams are identified by &quot;0:0&quot; and &quot;0:1&quot;. You can use -map to select which streams to place in an output file. For example:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0:1 out.wav\n</code></pre>\n<ul>\n<li>\n<p>will map the input stream in INPUT identified by &quot;0:1&quot; to the (single) output stream in out.wav.</p>\n</li>\n<li>\n<p>For example, to select the stream with index 2 from input file a.mov (specified by the identifier &quot;0:2&quot;), and stream with index 6 from input b.mov (specified by the identifier &quot;1:6&quot;), and copy them to the output file out.mov:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov\n</code></pre>\n<ul>\n<li>To select all video and the third audio stream from an input file:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT\n</code></pre>\n<ul>\n<li>To map all the streams except the second audio, use negative mappings</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT\n</code></pre>\n<ul>\n<li>To map the video and audio streams from the first input, and using the trailing ?, ignore the audio mapping if no audio streams exist in the first input:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT\n</code></pre>\n<ul>\n<li>To pick the English audio stream:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map 0:m:language:eng OUTPUT\n</code></pre>\n<ul>\n<li>Note that using this option disables the default mappings for this output file.</li>\n</ul>\n<p>-ignore_unknown</p>\n<ul>\n<li>Ignore input streams with unknown type instead of failing if copying such streams is attempted.</li>\n</ul>\n<p>-copy_unknown</p>\n<ul>\n<li>Allow input streams with unknown type to be copied instead of failing if copying such streams is attempted.</li>\n</ul>\n<p>-map_channel [input_file_id.stream_specifier.channel_id|-1][?][:output_file_id.stream_specifier]</p>\n<ul>\n<li>\n<p>Map an audio channel from a given input to an output. If output_file_id.stream_specifier is not set, the audio channel will be mapped on all the audio streams.</p>\n</li>\n<li>\n<p>Using &quot;-1&quot; instead of input_file_id.stream_specifier.channel_id will map a muted channel.</p>\n</li>\n<li>\n<p>A trailing ? will allow the map_channel to be optional: if the map_channel matches no channel the map_channel will be ignored instead of failing.</p>\n</li>\n<li>\n<p>For example, assuming INPUT is a stereo audio file, you can switch the two audio channels with the following command:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map_channel 0.0.1 -map_channel 0.0.0 OUTPUT\n</code></pre>\n<ul>\n<li>If you want to mute the first channel and keep the second:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map_channel -1 -map_channel 0.0.1 OUTPUT\n</code></pre>\n<ul>\n<li>\n<p>The order of the &quot;-map_channel&quot; option specifies the order of the channels in the output stream. The output channel layout is guessed from the number of channels mapped (mono if one &quot;-map_channel&quot;, stereo if two, etc.). Using &quot;-ac&quot; in combination of &quot;-map_channel&quot; makes the channel gain levels to be updated if input and output channel layouts don’t match (for instance two &quot;-map_channel&quot; options and &quot;-ac 6&quot;).</p>\n</li>\n<li>\n<p>You can also extract each channel of an input to specific outputs; the following command extracts two channels of the INPUT audio stream (file 0, stream 0) to the respective OUTPUT_CH0 and OUTPUT_CH1 outputs:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map_channel 0.0.0 OUTPUT_CH0 -map_channel 0.0.1 OUTPUT_CH1\n</code></pre>\n<ul>\n<li>The following example splits the channels of a stereo input into two separate streams, which are put into the same output file:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i stereo.wav -map 0:0 -map 0:0 -map_channel 0.0.0:0.0 -map_channel 0.0.1:0.1 -y out.ogg\n</code></pre>\n<ul>\n<li>\n<p>Note that currently each output stream can only contain channels from a single input stream; you can’t for example use &quot;-map_channel&quot; to pick multiple input audio channels contained in different streams (from the same or different files) and merge them into a single output stream. It is therefore not currently possible, for example, to turn two separate mono streams into a single stereo stream. However splitting a stereo stream into two single channel mono streams is possible.</p>\n</li>\n<li>\n<p>If you need this feature, a possible workaround is to use the amerge filter. For example, if you need to merge a media (here input.mkv) with 2 mono audio streams into one single stereo channel audio stream (and keep the video stream), you can use the following command:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i input.mkv -filter_complex &quot;[0:1] [0:2] amerge&quot; -c:a pcm_s16le -c:v copy output.mkv\n</code></pre>\n<ul>\n<li>To map the first two audio channels from the first input, and using the trailing ?, ignore the audio channel mapping if the first input is mono instead of stereo:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i INPUT -map_channel 0.0.0 -map_channel 0.0.1? OUTPUT\n</code></pre>\n<p>-map_metadata[:metadata_spec_out] infile[:metadata_spec_in] (output,per-metadata)</p>\n<ul>\n<li>\n<p>Set metadata information of the next output file from infile. Note that those are file indices (zero-based), not filenames. Optional metadata_spec_in/out parameters specify, which metadata to copy. A metadata specifier can have the following forms:</p>\n</li>\n<li>\n<p>g</p>\n<ul>\n<li>global metadata, i.e. metadata that applies to the whole file</li>\n</ul>\n</li>\n<li>\n<p>s[:stream_spec]</p>\n<ul>\n<li>per-stream metadata. stream_spec is a stream specifier as described in the Stream specifiers chapter. In an input metadata specifier, the first matching stream is copied from. In an output metadata specifier, all matching streams are copied to.</li>\n</ul>\n</li>\n<li>\n<p>c:chapter_index</p>\n<ul>\n<li>per-chapter metadata. chapter_index is the zero-based chapter index.</li>\n</ul>\n</li>\n<li>\n<p>p:program_index</p>\n<ul>\n<li>per-program metadata. program_index is the zero-based program index.</li>\n</ul>\n</li>\n<li>\n<p>If metadata specifier is omitted, it defaults to global.</p>\n</li>\n<li>\n<p>By default, global metadata is copied from the first input file, per-stream and per-chapter metadata is copied along with streams/chapters. These default mappings are disabled by creating any mapping of the relevant type. A negative file index can be used to create a dummy mapping that just disables automatic copying.</p>\n</li>\n<li>\n<p>For example to copy metadata from the first stream of the input file to global metadata of the output file:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.ogg -map_metadata 0:s:0 out.mp3\n</code></pre>\n<ul>\n<li>To do the reverse, i.e. copy global metadata to all audio streams:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i in.mkv -map_metadata:s:a 0:g out.mkv\n</code></pre>\n<ul>\n<li>Note that simple 0 would work as well in this example, since global metadata is assumed by default.</li>\n</ul>\n<p>-map_chapters input_file_index (output)</p>\n<ul>\n<li>Copy chapters from input file with index input_file_index to the next output file. If no chapter mapping is specified, then chapters are copied from the first input file with at least one chapter. Use a negative file index to disable any chapter copying.</li>\n</ul>\n<p>-benchmark (global)</p>\n<ul>\n<li>Show benchmarking information at the end of an encode. Shows real, system and user time used and maximum memory consumption. Maximum memory consumption is not supported on all systems, it will usually display as 0 if not supported.</li>\n</ul>\n<p>-benchmark_all (global)</p>\n<ul>\n<li>Show benchmarking information during the encode. Shows real, system and user time used in various steps (audio/video encode/decode).</li>\n</ul>\n<p>-timelimit duration (global)</p>\n<ul>\n<li>Exit after ffmpeg has been running for duration seconds in CPU user time.</li>\n</ul>\n<p>-dump (global)</p>\n<ul>\n<li>Dump each input packet to stderr.</li>\n</ul>\n<p>-hex (global)</p>\n<ul>\n<li>When dumping packets, also dump the payload.</li>\n</ul>\n<p>-readrate speed (input)</p>\n<ul>\n<li>\n<p>Limit input read speed.</p>\n</li>\n<li>\n<p>Its value is a floating-point positive number which represents the maximum duration of media, in seconds, that should be ingested in one second of wallclock time. Default value is zero and represents no imposed limitation on speed of ingestion. Value 1 represents real-time speed and is equivalent to -re.</p>\n</li>\n<li>\n<p>Mainly used to simulate a capture device or live input stream (e.g. when reading from a file). Should not be used with a low value when input is an actual capture device or live stream as it may cause packet loss.</p>\n</li>\n<li>\n<p>It is useful for when flow speed of output packets is important, such as live streaming.</p>\n</li>\n</ul>\n<p>-re (input)</p>\n<ul>\n<li>Read input at native frame rate. This is equivalent to setting -readrate 1.</li>\n</ul>\n<p>-vsync parameter</p>\n<ul>\n<li>\n<p>Video sync method.</p>\n</li>\n<li>\n<p>For compatibility reasons some of the values can be specified as numbers (shown in parentheses in the following table). This is deprecated and will stop working in the future.</p>\n</li>\n<li>\n<p>passthrough (0)</p>\n<ul>\n<li>Each frame is passed with its timestamp from the demuxer to the muxer.</li>\n</ul>\n</li>\n<li>\n<p>cfr (1)</p>\n<ul>\n<li>Frames will be duplicated and dropped to achieve exactly the requested constant frame rate.</li>\n</ul>\n</li>\n<li>\n<p>vfr (2)</p>\n<ul>\n<li>Frames are passed through with their timestamp or dropped so as to prevent 2 frames from having the same timestamp.</li>\n</ul>\n</li>\n<li>\n<p>drop</p>\n<ul>\n<li>As passthrough but destroys all timestamps, making the muxer generate fresh timestamps based on frame-rate.</li>\n</ul>\n</li>\n<li>\n<p>auto (-1)</p>\n<ul>\n<li>Chooses between cfr and vfr depending on muxer capabilities. This is the default method.</li>\n</ul>\n</li>\n<li>\n<p>Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option avoid_negative_ts is enabled.</p>\n</li>\n<li>\n<p>With -map you can select from which stream the timestamps should be taken. You can leave either video or audio unchanged and sync the remaining stream(s) to the unchanged one.</p>\n</li>\n</ul>\n<p>-frame_drop_threshold parameter</p>\n<ul>\n<li>Frame drop threshold, which specifies how much behind video frames can be before they are dropped. In frame rate units, so 1.0 is one frame. The default is -1.1. One possible usecase is to avoid framedrops in case of noisy timestamps or to increase frame drop precision in case of exact timestamps.</li>\n</ul>\n<p>-async samples_per_second</p>\n<ul>\n<li>\n<p>Audio sync method. &quot;Stretches/squeezes&quot; the audio stream to match the timestamps, the parameter is the maximum samples per second by which the audio is changed. -async 1 is a special case where only the start of the audio stream is corrected without any later correction.</p>\n</li>\n<li>\n<p>Note that the timestamps may be further modified by the muxer, after this. For example, in the case that the format option avoid_negative_ts is enabled.</p>\n</li>\n<li>\n<p>This option has been deprecated. Use the aresample audio filter instead.</p>\n</li>\n</ul>\n<p>-adrift_threshold time</p>\n<ul>\n<li>Set the minimum difference between timestamps and audio data (in seconds) to trigger adding/dropping samples to make it match the timestamps. This option effectively is a threshold to select between hard (add/drop) and soft (squeeze/stretch) compensation. -async must be set to a positive value.</li>\n</ul>\n<p>-apad parameters (output,per-stream)</p>\n<ul>\n<li>Pad the output audio stream(s). This is the same as applying -af apad. Argument is a string of filter parameters composed the same as with the apad filter. -shortest must be set for this output for the option to take effect.</li>\n</ul>\n<p>-copyts</p>\n<ul>\n<li>\n<p>Do not process input timestamps, but keep their values without trying to sanitize them. In particular, do not remove the initial start time offset value.</p>\n</li>\n<li>\n<p>Note that, depending on the vsync option or on specific muxer processing (e.g. in case the format option avoid_negative_ts is enabled) the output timestamps may mismatch with the input timestamps even when this option is selected.</p>\n</li>\n</ul>\n<p>-start_at_zero</p>\n<ul>\n<li>\n<p>When used with copyts, shift input timestamps so they start at zero.</p>\n</li>\n<li>\n<p>This means that using e.g. -ss 50 will make output timestamps start at 50 seconds, regardless of what timestamp the input file started at.</p>\n</li>\n</ul>\n<p>-copytb mode</p>\n<ul>\n<li>\n<p>Specify how to set the encoder timebase when stream copying. mode is an integer numeric value, and can assume one of the following values:</p>\n</li>\n<li>\n<p>1</p>\n<ul>\n<li>\n<p>Use the demuxer timebase.</p>\n</li>\n<li>\n<p>The time base is copied to the output encoder from the corresponding input demuxer. This is sometimes required to avoid non monotonically increasing timestamps when copying video streams with variable frame rate.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>0</p>\n<ul>\n<li>\n<p>Use the decoder timebase.</p>\n</li>\n<li>\n<p>The time base is copied to the output encoder from the corresponding input decoder.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>-1</p>\n<ul>\n<li>Try to make the choice automatically, in order to generate a sane output.</li>\n</ul>\n</li>\n<li>\n<p>Default value is -1.</p>\n</li>\n</ul>\n<p>-enc_time_base[:stream_specifier] timebase (output,per-stream)</p>\n<ul>\n<li>\n<p>Set the encoder timebase. timebase is a floating point number, and can assume one of the following values:</p>\n</li>\n<li>\n<p>0</p>\n<ul>\n<li>\n<p>Assign a default value according to the media type.</p>\n</li>\n<li>\n<p>For video - use 1/framerate, for audio - use 1/samplerate.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>-1</p>\n</li>\n<li>\n<p>Use the input stream timebase when possible.</p>\n<ul>\n<li>If an input stream is not available, the default timebase will be used.</li>\n</ul>\n</li>\n<li>\n<p>&gt;0</p>\n<ul>\n<li>\n<p>Use the provided number as the timebase.</p>\n</li>\n<li>\n<p>This field can be provided as a ratio of two integers (e.g. 1:24, 1:48000) or as a floating point number (e.g. 0.04166, 2.0833e-5)</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Default value is 0.</p>\n</li>\n</ul>\n<p>-bitexact (input/output)</p>\n<ul>\n<li>Enable bitexact mode for (de)muxer and (de/en)coder</li>\n</ul>\n<p>-shortest (output)</p>\n<ul>\n<li>Finish encoding when the shortest input stream ends.</li>\n</ul>\n<p>-dts_delta_threshold</p>\n<ul>\n<li>Timestamp discontinuity delta threshold.</li>\n</ul>\n<p>-dts_error_threshold seconds</p>\n<ul>\n<li>Timestamp error delta threshold. This threshold use to discard crazy/damaged timestamps and the default is 30 hours which is arbitrarily picked and quite conservative.</li>\n</ul>\n<p>-muxdelay seconds (output)</p>\n<ul>\n<li>Set the maximum demux-decode delay.</li>\n</ul>\n<p>-muxpreload seconds (output)</p>\n<ul>\n<li>Set the initial demux-decode delay.</li>\n</ul>\n<p>-streamid output-stream-index:new-value (output)</p>\n<ul>\n<li>\n<p>Assign a new stream-id value to an output stream. This option should be specified prior to the output filename to which it applies. For the situation where multiple output files exist, a streamid may be reassigned to a different value.</p>\n</li>\n<li>\n<p>For example, to set the stream 0 PID to 33 and the stream 1 PID to 36 for an output mpegts file:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i inurl -streamid 0:33 -streamid 1:36 out.ts\n</code></pre>\n<p>-bsf[:stream_specifier] bitstream_filters (output,per-stream)</p>\n<ul>\n<li>Set bitstream filters for matching streams. bitstream_filters is a comma-separated list of bitstream filters. Use the -bsfs option to get the list of bitstream filters.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i h264.mp4 -c:v copy -bsf:v h264_mp4toannexb -an out.h264\n</code></pre>\n<pre><code class=\"language-shell\">ffmpeg -i file.mov -an -vn -bsf:s mov2textsub -c:s copy -f rawvideo sub.txt\n</code></pre>\n<p>-tag[:stream_specifier] codec_tag (input/output,per-stream)</p>\n<ul>\n<li>Force a tag/fourcc for matching streams.</li>\n</ul>\n<p>-timecode hh:mm:ssSEPff</p>\n<ul>\n<li>Specify Timecode for writing. SEP is ’:’ for non drop timecode and ’;’ (or ’.’) for drop.</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i input.mpg -timecode 01:02:03.04 -r 30000/1001 -s ntsc output.mpg\n</code></pre>\n<p>-filter_complex filtergraph (global)</p>\n<ul>\n<li>\n<p>Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. For simple graphs – those with one input and one output of the same type – see the -filter options. filtergraph is a description of the filtergraph, as described in the “Filtergraph syntax” section of the ffmpeg-filters manual.</p>\n</li>\n<li>\n<p>Input link labels must refer to input streams using the [file_index:stream_specifier] syntax (i.e. the same as -map uses). If stream_specifier matches multiple streams, the first one will be used. An unlabeled input will be connected to the first unused input stream of the matching type.</p>\n</li>\n<li>\n<p>Output link labels are referred to with -map. Unlabeled outputs are added to the first output file.</p>\n</li>\n<li>\n<p>Note that with this option it is possible to use only lavfi sources without normal input files.</p>\n</li>\n<li>\n<p>For example, to overlay an image over video</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i video.mkv -i image.png -filter_complex '[0:v][1:v]overlay[out]' -map\n'[out]' out.mkv\n</code></pre>\n<ul>\n<li>\n<p>Here [0:v] refers to the first video stream in the first input file, which is linked to the first (main) input of the overlay filter. Similarly the first video stream in the second input is linked to the second (overlay) input of overlay.</p>\n</li>\n<li>\n<p>Assuming there is only one video stream in each input file, we can omit input labels, so the above is equivalent to</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i video.mkv -i image.png -filter_complex 'overlay[out]' -map\n'[out]' out.mkv\n</code></pre>\n<ul>\n<li>Furthermore we can omit the output label and the single output from the filter graph will be added to the output file automatically, so we can simply write</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i video.mkv -i image.png -filter_complex 'overlay' out.mkv\n</code></pre>\n<ul>\n<li>\n<p>As a special exception, you can use a bitmap subtitle stream as input: it will be converted into a video with the same size as the largest video in the file, or 720x576 if no video is present. Note that this is an experimental and temporary solution. It will be removed once libavfilter has proper support for subtitles.</p>\n</li>\n<li>\n<p>For example, to hardcode subtitles on top of a DVB-T recording stored in MPEG-TS format, delaying the subtitles by 1 second:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i input.ts -filter_complex \\\n'[#0x2ef] setpts=PTS+1/TB [sub] ; [#0x2d0] [sub] overlay' \\\n-sn -map '#0x2dc' output.mkv\n</code></pre>\n<ul>\n<li>\n<p>(0x2d0, 0x2dc and 0x2ef are the MPEG-TS PIDs of respectively the video, audio and subtitles streams; 0:0, 0:3 and 0:7 would have worked too)</p>\n</li>\n<li>\n<p>To generate 5 seconds of pure red video using lavfi color source:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -filter_complex 'color=c=red' -t 5 out.mkv\n</code></pre>\n<p>-filter_complex_threads nb_threads (global)</p>\n<ul>\n<li>Defines how many threads are used to process a filter_complex graph. Similar to filter_threads but used for -filter_complex graphs only. The default is the number of available CPUs.</li>\n</ul>\n<p>-lavfi filtergraph (global)</p>\n<ul>\n<li>Define a complex filtergraph, i.e. one with arbitrary number of inputs and/or outputs. Equivalent to -filter_complex.</li>\n</ul>\n<p>-filter_complex_script filename (global)</p>\n<ul>\n<li>This option is similar to -filter_complex, the only difference is that its argument is the name of the file from which a complex filtergraph description is to be read.</li>\n</ul>\n<p>-accurate_seek (input)</p>\n<ul>\n<li>This option enables or disables accurate seeking in input files with the -ss option. It is enabled by default, so seeking is accurate when transcoding. Use -noaccurate_seek to disable it, which may be useful e.g. when copying some streams and transcoding the others.</li>\n</ul>\n<p>-seek_timestamp (input)</p>\n<ul>\n<li>This option enables or disables seeking by timestamp in input files with the -ss option. It is disabled by default. If enabled, the argument to the -ss option is considered an actual timestamp, and is not offset by the start time of the file. This matters only for files which do not start from timestamp 0, such as transport streams.</li>\n</ul>\n<p>-thread_queue_size size (input)</p>\n<ul>\n<li>This option sets the maximum number of queued packets when reading from the file or device. With low latency / high rate live streams, packets may be discarded if they are not read in a timely manner; setting this value can force ffmpeg to use a separate input thread and read packets as soon as they arrive. By default ffmpeg only do this if multiple inputs are specified.</li>\n</ul>\n<p>-sdp_file file (global)</p>\n<ul>\n<li>Print sdp information for an output stream to file. This allows dumping sdp information when at least one output isn’t an rtp stream. (Requires at least one of the output formats to be rtp).</li>\n</ul>\n<p>-discard (input)</p>\n<ul>\n<li>\n<p>Allows discarding specific streams or frames from streams. Any input stream can be fully discarded, using value all whereas selective discarding of frames from a stream occurs at the demuxer and is not supported by all demuxers.</p>\n</li>\n<li>\n<p>none</p>\n<ul>\n<li>Discard no frame.</li>\n</ul>\n</li>\n<li>\n<p>default</p>\n<ul>\n<li>Default, which discards no frames.</li>\n</ul>\n</li>\n<li>\n<p>noref</p>\n<ul>\n<li>Discard all non-reference frames.</li>\n</ul>\n</li>\n<li>\n<p>bidir</p>\n<ul>\n<li>Discard all bidirectional frames.</li>\n</ul>\n</li>\n<li>\n<p>nokey</p>\n<ul>\n<li>Discard all frames excepts keyframes.</li>\n</ul>\n</li>\n<li>\n<p>all</p>\n<ul>\n<li>Discard all frames.</li>\n</ul>\n</li>\n</ul>\n<p>-abort_on flags (global)</p>\n<ul>\n<li>\n<p>Stop and abort on various conditions. The following flags are available:</p>\n</li>\n<li>\n<p>empty_output</p>\n<ul>\n<li>No packets were passed to the muxer, the output is empty.</li>\n</ul>\n</li>\n<li>\n<p>empty_output_stream</p>\n<ul>\n<li>No packets were passed to the muxer in some of the output streams.</li>\n</ul>\n</li>\n</ul>\n<p>-max_error_rate (global)</p>\n<ul>\n<li>Set fraction of decoding frame failures across all inputs which when crossed ffmpeg will return exit code 69. Crossing this threshold does not terminate processing. Range is a floating-point number between 0 to 1. Default is 2/3.</li>\n</ul>\n<p>-xerror (global)</p>\n<ul>\n<li>Stop and exit on error</li>\n</ul>\n<p>-max_muxing_queue_size packets (output,per-stream)</p>\n<ul>\n<li>\n<p>When transcoding audio and/or video streams, ffmpeg will not begin writing into the output until it has one packet for each such stream. While waiting for that to happen, packets for other streams are buffered. This option sets the size of this buffer, in packets, for the matching output stream.</p>\n</li>\n<li>\n<p>The default value of this option should be high enough for most uses, so only touch this option if you are sure that you need it.</p>\n</li>\n</ul>\n<p>-muxing_queue_data_threshold bytes (output,per-stream)</p>\n<ul>\n<li>This is a minimum threshold until which the muxing queue size is not taken into account. Defaults to 50 megabytes per stream, and is based on the overall size of packets passed to the muxer.</li>\n</ul>\n<p>-auto_conversion_filters (global)</p>\n<ul>\n<li>Enable automatically inserting format conversion filters in all filter graphs, including those defined by -vf, -af, -filter_complex and -lavfi. If filter format negotiation requires a conversion, the initialization of the filters will fail. Conversions can still be performed by inserting the relevant conversion filter (scale, aresample) in the graph. On by default, to explicitly disable it you need to specify -noauto_conversion_filters.</li>\n</ul>\n<p>-bits_per_raw_sample[:stream_specifier] value (output,per-stream)</p>\n<ul>\n<li>Declare the number of bits per raw sample in the given output stream to be value. Note that this option sets the information provided to the encoder/muxer, it does not change the stream to conform to this value. Setting values that do not match the stream properties may result in encoding failures or invalid output files.</li>\n</ul>\n<h3>5.12 Preset files</h3>\n<p>A preset file contains a sequence of option=value pairs,<br>\none for each line, specifying a sequence of options which would be<br>\nawkward to specify on the command line. Lines starting with the hash<br>\n(’#’) character are ignored and are used to provide comments. Check<br>\nthe [presets] directory in the FFmpeg source tree for examples.</p>\n<p>There are two types of preset files: ffpreset and avpreset files.</p>\n<h4>5.12.1 ffpreset files</h4>\n<p>ffpreset files are specified with the <code>vpre</code>, <code>apre</code>,<br>\n<code>spre</code>, and <code>fpre</code> options. The <code>fpre</code> option takes the<br>\nfilename of the preset instead of a preset name as input and can be<br>\nused for any kind of codec. For the <code>vpre</code>, <code>apre</code>, and<br>\n<code>spre</code> options, the options specified in a preset file are<br>\napplied to the currently selected codec of the same type as the preset<br>\noption.</p>\n<p>The argument passed to the <code>vpre</code>, <code>apre</code>, and <code>spre</code><br>\npreset options identifies the preset file to use according to the<br>\nfollowing rules:</p>\n<p>First ffmpeg searches for a file named arg.ffpreset in the<br>\ndirectories [$FFMPEG_DATADIR] (if set), and [$HOME/.ffmpeg], and in<br>\nthe datadir defined at configuration time (usually [PREFIX/share/ffmpeg])<br>\nor in a [ffpresets] folder along the executable on win32,<br>\nin that order. For example, if the argument is <code>libvpx-1080p</code>, it will<br>\nsearch for the file [libvpx-1080p.ffpreset].</p>\n<p>If no such file is found, then ffmpeg will search for a file named<br>\ncodec_name-arg.ffpreset in the above-mentioned<br>\ndirectories, where codec_name is the name of the codec to which<br>\nthe preset file options will be applied. For example, if you select<br>\nthe video codec with <code>-vcodec libvpx</code> and use <code>-vpre 1080p</code>,<br>\nthen it will search for the file [libvpx-1080p.ffpreset].</p>\n<h4>5.12.2 avpreset files</h4>\n<p>avpreset files are specified with the <code>pre</code> option. They work similar to<br>\nffpreset files, but they only allow encoder- specific options. Therefore, an<br>\noption=value pair specifying an encoder cannot be used.</p>\n<p>When the <code>pre</code> option is specified, ffmpeg will look for files with the<br>\nsuffix .avpreset in the directories [$AVCONV_DATADIR] (if set), and<br>\n[$HOME/.avconv], and in the datadir defined at configuration time (usually<br>\n[PREFIX/share/ffmpeg]), in that order.</p>\n<p>First ffmpeg searches for a file named codec_name-arg.avpreset in<br>\nthe above-mentioned directories, where codec_name is the name of the codec<br>\nto which the preset file options will be applied. For example, if you select the<br>\nvideo codec with <code>-vcodec libvpx</code> and use <code>-pre 1080p</code>, then it will<br>\nsearch for the file [libvpx-1080p.avpreset].</p>\n<p>If no such file is found, then ffmpeg will search for a file named<br>\narg.avpreset in the same directories.</p>\n<h2>6 Examples</h2>\n<h3>6.1 Video and Audio grabbing</h3>\n<p>If you specify the input format and device then ffmpeg can grab video<br>\nand audio directly.</p>\n<pre><code class=\"language-shell\">ffmpeg -f oss -i /dev/dsp -f video4linux2 -i /dev/video0 /tmp/out.mpg\n</code></pre>\n<p>Or with an ALSA audio source (mono input, card id 1) instead of OSS:</p>\n<pre><code class=\"language-shell\">ffmpeg -f alsa -ac 1 -i hw:1 -f video4linux2 -i /dev/video0 /tmp/out.mpg\n</code></pre>\n<p>Note that you must activate the right video source and channel before<br>\nlaunching ffmpeg with any TV viewer such as<br>\nxawtv by Gerd Knorr. You also<br>\nhave to set the audio recording levels correctly with a<br>\nstandard mixer.</p>\n<h3>6.2 X11 grabbing</h3>\n<p>Grab the X11 display with ffmpeg via</p>\n<pre><code class=\"language-shell\">ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0 /tmp/out.mpg\n</code></pre>\n<p>0.0 is display.screen number of your X11 server, same as<br>\nthe DISPLAY environment variable.</p>\n<pre><code class=\"language-shell\">ffmpeg -f x11grab -video_size cif -framerate 25 -i :0.0+10,20 /tmp/out.mpg\n</code></pre>\n<p>0.0 is display.screen number of your X11 server, same as the DISPLAY environment<br>\nvariable. 10 is the x-offset and 20 the y-offset for the grabbing.</p>\n<h3>6.3 Video and Audio file format</h3>\n<p>Any supported file format and protocol can serve as input to ffmpeg:</p>\n<p>Examples:</p>\n<ul>\n<li>You can use YUV files as input:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i /tmp/test%d.Y /tmp/out.mpg\n</code></pre>\n<ul>\n<li>It will use the files:</li>\n</ul>\n<pre><code class=\"language-shell\">/tmp/test0.Y, /tmp/test0.U, /tmp/test0.V,\n/tmp/test1.Y, /tmp/test1.U, /tmp/test1.V, etc...\n</code></pre>\n<ul>\n<li>\n<p>The Y files use twice the resolution of the U and V files. They are<br>\nraw files, without header. They can be generated by all decent video<br>\ndecoders. You must specify the size of the image with the [-s] option<br>\nif ffmpeg cannot guess it.</p>\n</li>\n<li>\n<p>You can input from a raw YUV420P file:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i /tmp/test.yuv /tmp/out.avi\n</code></pre>\n<ul>\n<li>\n<p>test.yuv is a file containing raw YUV planar data. Each frame is composed<br>\nof the Y plane followed by the U and V planes at half vertical and<br>\nhorizontal resolution.</p>\n</li>\n<li>\n<p>You can output to a raw YUV420P file:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i mydivx.avi hugefile.yuv\n</code></pre>\n<ul>\n<li>You can set several input files and output files:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i /tmp/a.wav -s 640x480 -i /tmp/a.yuv /tmp/a.mpg\n</code></pre>\n<ul>\n<li>\n<p>Converts the audio file a.wav and the raw YUV video file a.yuv<br>\nto MPEG file a.mpg.</p>\n</li>\n<li>\n<p>You can also do audio and video conversions at the same time:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i /tmp/a.wav -ar 22050 /tmp/a.mp2\n</code></pre>\n<ul>\n<li>\n<p>Converts a.wav to MPEG audio at 22050 Hz sample rate.</p>\n</li>\n<li>\n<p>You can encode to several formats at the same time and define a<br>\nmapping from input stream to output streams:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i /tmp/a.wav -map 0:a -b:a 64k /tmp/a.mp2 -map 0:a -b:a 128k /tmp/b.mp2\n</code></pre>\n<ul>\n<li>\n<p>Converts a.wav to a.mp2 at 64 kbits and to b.mp2 at 128 kbits. ’-map<br>\nfile:index’ specifies which input stream is used for each output<br>\nstream, in the order of the definition of output streams.</p>\n</li>\n<li>\n<p>You can transcode decrypted VOBs:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i snatch_1.vob -f avi -c:v mpeg4 -b:v 800k -g 300 -bf 2 -c:a libmp3lame -b:a 128k snatch.avi\n</code></pre>\n<ul>\n<li>\n<p>This is a typical DVD ripping example; the input is a VOB file, the<br>\noutput an AVI file with MPEG-4 video and MP3 audio. Note that in this<br>\ncommand we use B-frames so the MPEG-4 stream is DivX5 compatible, and<br>\nGOP size is 300 which means one intra frame every 10 seconds for 29.97fps<br>\ninput video. Furthermore, the audio stream is MP3-encoded so you need<br>\nto enable LAME support by passing <code>--enable-libmp3lame</code> to configure.<br>\nThe mapping is particularly useful for DVD transcoding<br>\nto get the desired audio language.</p>\n</li>\n<li>\n<p>NOTE: To see the supported input formats, use <code>ffmpeg -demuxers</code>.</p>\n</li>\n<li>\n<p>You can extract images from a video, or create a video from many images:</p>\n</li>\n<li>\n<p>For extracting images from a video:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg\n</code></pre>\n<ul>\n<li>\n<p>This will extract one video frame per second from the video and will<br>\noutput them in files named [foo-001.jpeg], [foo-002.jpeg],<br>\netc. Images will be rescaled to fit the new WxH values.</p>\n</li>\n<li>\n<p>If you want to extract just a limited number of frames, you can use the<br>\nabove command in combination with the <code>-frames:v</code> or <code>-t</code> option,<br>\nor in combination with -ss to start extracting from a certain point in time.</p>\n</li>\n<li>\n<p>For creating a video from many images:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -f image2 -framerate 12 -i foo-%03d.jpeg -s WxH foo.avi\n</code></pre>\n<ul>\n<li>\n<p>The syntax <code>foo-%03d.jpeg</code> specifies to use a decimal number<br>\ncomposed of three digits padded with zeroes to express the sequence<br>\nnumber. It is the same syntax supported by the C printf function, but<br>\nonly formats accepting a normal integer are suitable.</p>\n</li>\n<li>\n<p>When importing an image sequence, -i also supports expanding<br>\nshell-like wildcard patterns (globbing) internally, by selecting the<br>\nimage2-specific <code>-pattern_type glob</code> option.</p>\n</li>\n<li>\n<p>For example, for creating a video from filenames matching the glob pattern<br>\n<code>foo-*.jpeg</code>:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -f image2 -pattern_type glob -framerate 12 -i 'foo-*.jpeg' -s WxH foo.avi\n</code></pre>\n<ul>\n<li>You can put many streams of the same type in the output:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i test1.avi -i test2.avi -map 1:1 -map 1:0 -map 0:1 -map 0:0 -c copy -y test12.nut\n</code></pre>\n<ul>\n<li>\n<p>The resulting output file [test12.nut] will contain the first four streams<br>\nfrom the input files in reverse order.</p>\n</li>\n<li>\n<p>To force CBR video output:</p>\n</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i myfile.avi -b 4000k -minrate 4000k -maxrate 4000k -bufsize 1835k out.m2v\n</code></pre>\n<ul>\n<li>The four options lmin, lmax, mblmin and mblmax use ’lambda’ units,<br>\nbut you may use the QP2LAMBDA constant to easily convert from ’q’ units:</li>\n</ul>\n<pre><code class=\"language-shell\">ffmpeg -i src.ext -lmax 21*QP2LAMBDA dst.ext\n</code></pre>\n<h2>7 See Also</h2>\n<p><a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-all.html\">ffmpeg-all</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffplay.html\">ffplay</a>, <a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffprobe.html\">ffprobe</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-utils.html\">ffmpeg-utils</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-scaler.html\">ffmpeg-scaler</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-resampler.html\">ffmpeg-resampler</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-codecs.html\">ffmpeg-codecs</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-bitstream-filters.html\">ffmpeg-bitstream-filters</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-formats.html\">ffmpeg-formats</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-devices.html\">ffmpeg-devices</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-protocols.html\">ffmpeg-protocols</a>,<br>\n<a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"ffmpeg-filters.html\">ffmpeg-filters</a></p>\n<h2>8 Authors</h2>\n<p>The FFmpeg developers.</p>\n<p>For details about the authorship, see the Git history of the project (git://source.ffmpeg.org/ffmpeg), e.g. by typing the command <code>git log</code> in the FFmpeg source directory, or browsing the online repository at <a data-target=\"_blank\"  referrerpolicy=\"no-referrer\" href=\"http://source.ffmpeg.org\">http://source.ffmpeg.org</a>.</p>\n<p>Maintainers for the specific components are listed in the file MAINTAINERS in the source code tree.</p>\n<p>This document was generated on January 5, 2022 using makeinfo.</p>\n</div>","title":"ffmpeg documentation 英文文档","date":"2021-12-27 20:57:01","tags":"","categories":""},"allData":[{"label":"前端","key":"前端","children":[{"label":"IDE","key":"前端IDE","children":[{"label":"sublime_text3_package_control_报错","key":"IDEsublime_text3_package_control_报错","data":{"date":"2018-05-26 04:33:58"}},{"label":"sublime_text_2学习(二)_创建可复用的代码片段","key":"IDEsublime_text_2学习(二)_创建可复用的代码片段","data":{"date":"2014/5/20 11:34:00"}},{"label":"vscode控制台输出中文乱码","key":"IDEvscode控制台输出中文乱码","data":{"date":"2021/8/19 10:24:10"}},{"label":"webStorm_clone一个新的项目（一个项目clone多分）","key":"IDEwebStorm_clone一个新的项目（一个项目clone多分）","data":{"date":"2020/12/8 1:25:00"}},{"label":"webStorm_提交git时跳过eslint校验","key":"IDEwebStorm_提交git时跳过eslint校验","data":{"date":"2020/10/12 5:15:10"}},{"label":"webStorm中跳过本地变更更新远程代码","key":"IDEwebStorm中跳过本地变更更新远程代码","data":{"date":"2020/10/12 5:09:41"}},{"label":"webStorm找回误删文件和历史操作痕迹","key":"IDEwebStorm找回误删文件和历史操作痕迹","data":{"date":"2020/9/21 11:34:41"}},{"label":"webpack编译遇到的问题_Error_Cannot_find_module_webpack-cli_bin_config-yargs_","key":"IDEwebpack编译遇到的问题_Error_Cannot_find_module_webpack-cli_bin_config-yargs_","data":{"date":"2021/8/2 9:08:07"}},{"label":"webstorm全局搜索搜不到内容","key":"IDEwebstorm全局搜索搜不到内容","data":{"date":"2021/5/5 4:47:19"}},{"label":"免费获取JetBrains全家桶正版License教程_","key":"IDE免费获取JetBrains全家桶正版License教程_","data":{"date":"2020/11/12 5:03:51"}}]},{"label":"css","key":"前端css","children":[{"label":"IE6_IE7_IE8的CSS_JS兼容","key":"cssIE6_IE7_IE8的CSS_JS兼容","data":{"date":"2014/5/20 11:13:00"}},{"label":"css3_呼吸动画按钮","key":"csscss3_呼吸动画按钮","data":{"date":"2014/11/27 3:54:00"}},{"label":"css3_实现一个k歌效果和一个进度条的效果","key":"csscss3_实现一个k歌效果和一个进度条的效果","data":{"date":"2021-11-08 10:34:54"}},{"label":"css3_实现圆角的三角形","key":"csscss3_实现圆角的三角形","data":{"date":"2018-05-04 07:13:45"}},{"label":"css3_实现自定义有序列表序号","key":"csscss3_实现自定义有序列表序号","data":{"date":"2017-07-15 10:42:07"}},{"label":"css3实现信纸_同学录效果","key":"csscss3实现信纸_同学录效果","data":{"date":"2018-12-05 10:30:17"}},{"label":"css3水滴效果_地图标记效果","key":"csscss3水滴效果_地图标记效果","data":{"date":"2018-01-05 03:20:23"}},{"label":"css3漂亮的按钮","key":"csscss3漂亮的按钮","data":{"date":"2014/11/28 4:56:00"}},{"label":"css_选择器种类","key":"csscss_选择器种类","data":{"date":"2014/11/16 7:54:00"}},{"label":"css强制换行_禁止换行_的几种写法","key":"csscss强制换行_禁止换行_的几种写法","data":{"date":"2020/9/29 10:03:43"}},{"label":"css背景图与html插入img的区别","key":"csscss背景图与html插入img的区别","data":{"date":"2014/5/9 11:05:00"}},{"label":"html背景图不随滚轮滚动_而且按住Ctrl并滚动滚轮时_图片不会变大缩小_就像百度的首页一样","key":"csshtml背景图不随滚轮滚动_而且按住Ctrl并滚动滚轮时_图片不会变大缩小_就像百度的首页一样","data":{"date":"2018-10-24 03:12:19"}},{"label":"svg_css3做一个动感的波浪效果","key":"csssvg_css3做一个动感的波浪效果","data":{"date":"2019-06-27 03:24:45"}},{"label":"使用css3的radial-gradient实现一个穿透效果的圆","key":"css使用css3的radial-gradient实现一个穿透效果的圆","data":{"date":"2017-10-23 11:40:02"}},{"label":"如何在CSS文件里加入变量","key":"css如何在CSS文件里加入变量","data":{"date":"2014/5/22 8:46:00"}},{"label":"纯css3实现二维码扫描特效","key":"css纯css3实现二维码扫描特效","data":{"date":"2020-03-09 05:19:14"}}]},{"label":"framework","key":"前端framework","children":[{"label":"Material_Design_for_Bootstrap","key":"frameworkMaterial_Design_for_Bootstrap","data":{"date":"2017-12-14 06:20:46"}},{"label":"Nextjs_Warning__A_title_element_received_an_array_with_more_than_1_element_as_children","key":"frameworkNextjs_Warning__A_title_element_received_an_array_with_more_than_1_element_as_children","data":{"date":"2023-01-19 21:56:46"}},{"label":"React中typescript文件引入图片报错问题","key":"frameworkReact中typescript文件引入图片报错问题","data":{"date":"2021-12-13 17:30:39"}},{"label":"ant-design-vue_1.5.1支持的所有语言列表","key":"frameworkant-design-vue_1.5.1支持的所有语言列表","data":{"date":"2020/9/17 4:31:48"}},{"label":"ant-design-vue_1.5.1组件完整列表","key":"frameworkant-design-vue_1.5.1组件完整列表","data":{"date":"2020/9/17 4:28:18"}},{"label":"ant-design-vue_按需加载遇到坑-less报错","key":"frameworkant-design-vue_按需加载遇到坑-less报错","data":{"date":"2020-06-12 09:41:51"}},{"label":"ant-design-vue按需引用组件","key":"frameworkant-design-vue按需引用组件","data":{"date":"2020/9/17 11:00:28"}},{"label":"ant_design中的Dropdown.Button如何使用幽灵按钮","key":"frameworkant_design中的Dropdown.Button如何使用幽灵按钮","data":{"date":"2021/6/24 11:50:30"}},{"label":"ant多语言配置_moment多语言配置","key":"frameworkant多语言配置_moment多语言配置","data":{"date":"2020/9/17 4:22:05"}},{"label":"ant按需加载改版自动化脚本","key":"frameworkant按需加载改版自动化脚本","data":{"date":"2020/9/17 1:50:48"}},{"label":"element-ui_中form表单有且今有一个输入框时会执行form的submit","key":"frameworkelement-ui_中form表单有且今有一个输入框时会执行form的submit","data":{"date":"2020-06-29 04:55:57"}},{"label":"element-ui的tabs页签页组件在使用vue-i18n切换语言后_按钮宽度发生变化之后定位不准确解决方案","key":"frameworkelement-ui的tabs页签页组件在使用vue-i18n切换语言后_按钮宽度发生变化之后定位不准确解决方案","data":{"date":"2020-05-15 01:25:09"}},{"label":"node_vue_react项目install_build时提示not_found_python2.x","key":"frameworknode_vue_react项目install_build时提示not_found_python2.x","data":{"date":"2020/12/7 2:34:45"}},{"label":"puppeteer安装失败解决方案","key":"frameworkpuppeteer安装失败解决方案","data":{"date":"2022-01-13 01:32:24"}},{"label":"react怎么在useEffect中使用async异步函数","key":"frameworkreact怎么在useEffect中使用async异步函数","data":{"date":"2021/5/25 6:40:24"}},{"label":"react项目报红色警告_UNSAFE_componentWillMount_in_strict_mode_is_not_recommended","key":"frameworkreact项目报红色警告_UNSAFE_componentWillMount_in_strict_mode_is_not_recommended","data":{"date":"2021/6/23 4:34:14"}},{"label":"setState是异步方法","key":"frameworksetState是异步方法","data":{"date":"2020/10/10 4:42:44"}},{"label":"useEffect中获取之前的值","key":"frameworkuseEffect中获取之前的值","data":{"date":"2022-01-05 11:10:34"}},{"label":"vue-cli_electron_开发桌面应用教程","key":"frameworkvue-cli_electron_开发桌面应用教程","data":{"date":"2020/11/12 10:14:59"}},{"label":"vue2_ref的用法_简单易懂——vue2子组件索引","key":"frameworkvue2_ref的用法_简单易懂——vue2子组件索引","data":{"date":"2017-04-13 02:27:06"}},{"label":"vue_react_angular开发的页面_如何在控制台修改受控表单域的值","key":"frameworkvue_react_angular开发的页面_如何在控制台修改受控表单域的值","data":{"date":"2021/9/18 10:00:09"}},{"label":"vuejs2遇到的一些坑","key":"frameworkvuejs2遇到的一些坑","data":{"date":"2017-03-03 04:51:12"}},{"label":"vuejs在chrome_extensions中不起作用","key":"frameworkvuejs在chrome_extensions中不起作用","data":{"date":"2016-11-19 03:10:53"}},{"label":"vue实现一个6个输入框的验证码输入组件","key":"frameworkvue实现一个6个输入框的验证码输入组件","data":{"date":"2020-06-30 02:57:22"}},{"label":"vue打包报错UnhandledPromiseRejectionWarning_CssSyntaxError_","key":"frameworkvue打包报错UnhandledPromiseRejectionWarning_CssSyntaxError_","data":{"date":"2020-03-11 12:08:46"}},{"label":"如何监听Ant_Design_of_React_的Search组件设置allowClear后的点击事件_","key":"framework如何监听Ant_Design_of_React_的Search组件设置allowClear后的点击事件_","data":{"date":"2020-09-27 10:40:01"}},{"label":"对React_Vue_Angular项目的页面模拟输入input_来实现自动输入功能","key":"framework对React_Vue_Angular项目的页面模拟输入input_来实现自动输入功能","data":{"date":"2020/12/17 9:23:37"}},{"label":"常用链接","key":"framework常用链接","data":{"date":"2020/9/17 7:22:04"}},{"label":"快速实现_react_多语言改造","key":"framework快速实现_react_多语言改造","data":{"date":"2021/5/19 2:56:43"}}]},{"label":"git","key":"前端git","children":[{"label":"git常用命令整理以及详解","key":"gitgit常用命令整理以及详解","data":{"date":"2017-06-19 04:20:37"}},{"label":"同时配置多套sshkey授权不同的代码仓库","key":"git同时配置多套sshkey授权不同的代码仓库","data":{"date":"2021-12-14 22:16:54"}},{"label":"批量修改指定仓库的git_username_和git_useremail","key":"git批量修改指定仓库的git_username_和git_useremail","data":{"date":"2020/12/7 2:30:21"}}]},{"label":"github","key":"前端github","children":[{"label":"github_action使用","key":"githubgithub_action使用","data":{"date":"2022-01-10 21:28:52"}},{"label":"github配置ssh_key_提交代码","key":"githubgithub配置ssh_key_提交代码","data":{"date":"2021/4/15 1:15:10"}}]},{"label":"html","key":"前端html","children":[{"label":"html5_标签picture用法","key":"htmlhtml5_标签picture用法","data":{"date":"2017-12-09 12:47:15"}},{"label":"解决input_type=file_打开时慢_卡顿问题","key":"html解决input_type=file_打开时慢_卡顿问题","data":{"date":"2020/11/9 1:56:16"}}]},{"label":"js","key":"前端js","children":[{"label":"300_毫秒点击延迟的来龙去脉_以及临时的解决方案","key":"js300_毫秒点击延迟的来龙去脉_以及临时的解决方案","data":{"date":"2014/11/10 5:50:00"}},{"label":"ajax_与_post_的区别_以及_post的bug","key":"jsajax_与_post_的区别_以及_post的bug","data":{"date":"2017-06-15 04:00:09"}},{"label":"canvas_生成海报","key":"jscanvas_生成海报","data":{"date":"2021/7/28 3:17:36"}},{"label":"canvas读取图片报错_Tainted_canvases_may_not_be_exported","key":"jscanvas读取图片报错_Tainted_canvases_may_not_be_exported","data":{"date":"2021/7/27 4:31:18"}},{"label":"chrome_监听touch类事件报错_无法被动侦听事件preventDefault","key":"jschrome_监听touch类事件报错_无法被动侦听事件preventDefault","data":{"date":"2016-11-28 12:16:34"}},{"label":"fn有toString方法_string没有toFunction方法_自定义一个toFunction方法","key":"jsfn有toString方法_string没有toFunction方法_自定义一个toFunction方法","data":{"date":"2018-04-18 12:30:32"}},{"label":"h5实现主播端推流","key":"jsh5实现主播端推流","data":{"date":"2021/2/7 2:30:33"}},{"label":"html5_indexeddb的简明api","key":"jshtml5_indexeddb的简明api","data":{"date":"2018-09-26 07:28:12"}},{"label":"jQuery实现锚点与链接之间的平滑滚动","key":"jsjQuery实现锚点与链接之间的平滑滚动","data":{"date":"2014/4/29 4:25:00"}},{"label":"javascript简单实现xml2json","key":"jsjavascript简单实现xml2json","data":{"date":"2022-01-04 16:56:12"}},{"label":"jquery_tag页签切换","key":"jsjquery_tag页签切换","data":{"date":"2014/5/11 3:53:00"}},{"label":"js_javascript_将中文数字转成阿拉伯数字","key":"jsjs_javascript_将中文数字转成阿拉伯数字","data":{"date":"2021/4/9 11:12:00"}},{"label":"js_判断浏览器关闭事件_兼容所有浏览器","key":"jsjs_判断浏览器关闭事件_兼容所有浏览器","data":{"date":"2014/5/10 4:27:00"}},{"label":"js_对象深度拷贝","key":"jsjs_对象深度拷贝","data":{"date":"2018/9/12 10:48:00"}},{"label":"js_导出excel_elsx格式","key":"jsjs_导出excel_elsx格式","data":{"date":"2018-11-21 01:34:16"}},{"label":"js_提示窗","key":"jsjs_提示窗","data":{"date":"2014/12/22 9:58:00"}},{"label":"js_操作cookie","key":"jsjs_操作cookie","data":{"date":"2014/11/27 4:25:00"}},{"label":"js_数组中自定义属性的应用","key":"jsjs_数组中自定义属性的应用","data":{"date":"2016-05-20 11:30:20"}},{"label":"js_数组去重_单元素和对象数组_","key":"jsjs_数组去重_单元素和对象数组_","data":{"date":"2019-05-05 03:29:09"}},{"label":"js_时间任意格式化_又来造轮子了","key":"jsjs_时间任意格式化_又来造轮子了","data":{"date":"2016-08-24 10:56:08"}},{"label":"js中文简体繁体切换","key":"jsjs中文简体繁体切换","data":{"date":"2016-08-10 06:08:26"}},{"label":"js中的toFixed保留小数位的功能优化","key":"jsjs中的toFixed保留小数位的功能优化","data":{"date":"2017-11-14 10:59:00"}},{"label":"js实现文件切片上传_断点续传","key":"jsjs实现文件切片上传_断点续传","data":{"date":"2018-04-02 06:24:13"}},{"label":"js数字计算丢失精度问题解决方案","key":"jsjs数字计算丢失精度问题解决方案","data":{"date":"2021-08-31 05:38:53"}},{"label":"js数组排序踩的一个坑","key":"jsjs数组排序踩的一个坑","data":{"date":"2017-12-12 02:46:32"}},{"label":"js校验文件唯一性","key":"jsjs校验文件唯一性","data":{"date":"2017-05-17 11:02:25"}},{"label":"js正则断言整理","key":"jsjs正则断言整理","data":{"date":"2017-12-14 06:26:40"}},{"label":"js深度解析url地址","key":"jsjs深度解析url地址","data":{"date":"2016-08-09 02:30:31"}},{"label":"js简单倒计时","key":"jsjs简单倒计时","data":{"date":"2018-12-12 10:15:21"}},{"label":"js简单实现图片本地预览效果","key":"jsjs简单实现图片本地预览效果","data":{"date":"2018-04-09 05:47:16"}},{"label":"js读写剪切板(ES6方案和兼容方案)","key":"jsjs读写剪切板(ES6方案和兼容方案)","data":{"date":"2021/9/14 5:22:18"}},{"label":"js通过CSV倒入excel数据","key":"jsjs通过CSV倒入excel数据","data":{"date":"2018-06-01 02:19:52"}},{"label":"一个html标签到底包含了多少信息_1_","key":"js一个html标签到底包含了多少信息_1_","data":{"date":"2016-06-14 05:20:52"}},{"label":"一个链接能打开win10设置界面","key":"js一个链接能打开win10设置界面","data":{"date":"2017-11-26 05:42:34"}},{"label":"一个面试题_两个四位数_翻转数字后与原数4倍关系","key":"js一个面试题_两个四位数_翻转数字后与原数4倍关系","data":{"date":"2017-03-08 02:39:58"}},{"label":"为什么要把jsonp理解的那么神圣_一个动态的js文件而已","key":"js为什么要把jsonp理解的那么神圣_一个动态的js文件而已","data":{"date":"2016-04-20 04:54:40"}},{"label":"从jquery_zepto中提取的90行代码实现一个完整的ajax","key":"js从jquery_zepto中提取的90行代码实现一个完整的ajax","data":{"date":"2016-12-01 05:27:30"}},{"label":"使用chrome_remote_debug时打开inspect时出现一片空白","key":"js使用chrome_remote_debug时打开inspect时出现一片空白","data":{"date":"2016-12-13 02:53:58"}},{"label":"使用js对被转义的特殊符号_如_amp;nbsp;_进行反转义","key":"js使用js对被转义的特殊符号_如_amp;nbsp;_进行反转义","data":{"date":"2016-11-22 10:22:10"}},{"label":"兼容ie5-ie11及其他主流浏览器的js_document.getElementsByClassName_方法","key":"js兼容ie5-ie11及其他主流浏览器的js_document.getElementsByClassName_方法","data":{"date":"2014/6/29 3:59:00"}},{"label":"初入ajax","key":"js初入ajax","data":{"date":"2014/12/8 11:52:00"}},{"label":"前端js监听浏览器网络变化","key":"js前端js监听浏览器网络变化","data":{"date":"2020-09-14 10:57:52"}},{"label":"前端黑科技-如何使用防盗链图片","key":"js前端黑科技-如何使用防盗链图片","data":{"date":"2018-11-05 07:12:46"}},{"label":"十行_js_获取带有双字节字符的字符串长度","key":"js十行_js_获取带有双字节字符的字符串长度","data":{"date":"2020-06-16 08:45:46"}},{"label":"原生javascript的一些好用的小技巧1","key":"js原生javascript的一些好用的小技巧1","data":{"date":"2018-09-26 10:28:01"}},{"label":"原生js_对图片的压缩上传","key":"js原生js_对图片的压缩上传","data":{"date":"2014/11/27 4:20:00"}},{"label":"原生js替换jQuery各种方法-中文版","key":"js原生js替换jQuery各种方法-中文版","data":{"date":"2018-10-10 03:06:12"}},{"label":"原生js给dom包裹一层父标签","key":"js原生js给dom包裹一层父标签","data":{"date":"2021-12-30 23:45:16"}},{"label":"如何使用防盗链的图片_","key":"js如何使用防盗链的图片_","data":{"date":"2021/2/26 10:33:18"}},{"label":"如何在页面引用外部的html","key":"js如何在页面引用外部的html","data":{"date":"2017-08-31 11:27:48"}},{"label":"数组去重","key":"js数组去重","data":{"date":"2020/11/25 6:58:12"}},{"label":"时间片段合并","key":"js时间片段合并","data":{"date":"2021/8/12 11:49:18"}},{"label":"正则中的_1的作用","key":"js正则中的_1的作用","data":{"date":"2017-12-28 01:40:22"}},{"label":"正则匹配常见链接地址","key":"js正则匹配常见链接地址","data":{"date":"2016-10-13 07:31:36"}},{"label":"浏览器不支持播放flash_一个神奇的链接解决问题","key":"js浏览器不支持播放flash_一个神奇的链接解决问题","data":{"date":"2017-05-25 08:13:10"}},{"label":"火狐浏览器竟然不支持body_scrollTop","key":"js火狐浏览器竟然不支持body_scrollTop","data":{"date":"2016-08-10 05:38:10"}},{"label":"简体中文转繁体中文_并可区分港台繁体","key":"js简体中文转繁体中文_并可区分港台繁体","data":{"date":"2019-10-03 11:21:39"}},{"label":"简单高效实现一个按需加载图片的逻辑_","key":"js简单高效实现一个按需加载图片的逻辑_","data":{"date":"2019-08-02 02:54:20"}},{"label":"给自己的博客添加无刷新跳转","key":"js给自己的博客添加无刷新跳转","data":{"date":"2021-12-31 02:51:53"}},{"label":"给自己的网站接入谷歌翻译_以及修复了一个谷歌翻译的一个bug","key":"js给自己的网站接入谷歌翻译_以及修复了一个谷歌翻译的一个bug","data":{"date":"2019-12-13 12:34:02"}},{"label":"网站中_如何通过一个信息_确定该标签的在页面的位置信息_","key":"js网站中_如何通过一个信息_确定该标签的在页面的位置信息_","data":{"date":"2016-04-21 09:23:17"}},{"label":"网站追中技术-前端持久化-evercookie","key":"js网站追中技术-前端持久化-evercookie","data":{"date":"2021/6/2 12:46:18"}},{"label":"网页中实现Ctrl_f搜索功能","key":"js网页中实现Ctrl_f搜索功能","data":{"date":"2020/9/28 1:15:33"}},{"label":"解决qrcode_js生成二维码时必须定义一个空div的问题","key":"js解决qrcode_js生成二维码时必须定义一个空div的问题","data":{"date":"2020-07-09 08:32:36"}}]},{"label":"markdown","key":"前端markdown","children":[{"label":"markdown中使用变量","key":"markdownmarkdown中使用变量","data":{"date":"2021-12-24 13:24:02"}},{"label":"实现md合并单元格","key":"markdown实现md合并单元格","data":{"date":"2021-12-29 14:50:33"}}]},{"label":"npm_yarn","key":"前端npm_yarn","children":[{"label":"Building_fresh_packages_很长时间无反应","key":"npm_yarnBuilding_fresh_packages_很长时间无反应","data":{"date":"2021/7/26 1:24:20"}},{"label":"Failed_to_connect_to_github.com_port_443_Timed_out","key":"npm_yarnFailed_to_connect_to_github.com_port_443_Timed_out","data":{"date":"2021/5/25 8:58:22"}},{"label":"RPC_failed;_curl_56_OpenSSL_SSL_read_Connection_was_reset,_errno_10054","key":"npm_yarnRPC_failed;_curl_56_OpenSSL_SSL_read_Connection_was_reset,_errno_10054","data":{"date":"2021/5/25 8:55:38"}},{"label":"npm_yarn_切换安装源或使用代理进行安装","key":"npm_yarnnpm_yarn_切换安装源或使用代理进行安装","data":{"date":"2021/5/14 11:09:15"}},{"label":"nrm_ls_报错_ERR_INVALID_ARG_TYPE","key":"npm_yarnnrm_ls_报错_ERR_INVALID_ARG_TYPE","data":{"date":"2021/8/18 11:25:58"}},{"label":"nrm——npm镜像管理工具使用入门","key":"npm_yarnnrm——npm镜像管理工具使用入门","data":{"date":"2021/5/14 11:41:10"}},{"label":"vscode中_yarn_无法加载文件_C_Users_Admin_AppData_Roaming_npm_yarn.ps1,因为在此系统因为在此系统上禁止运行脚本","key":"npm_yarnvscode中_yarn_无法加载文件_C_Users_Admin_AppData_Roaming_npm_yarn.ps1,因为在此系统因为在此系统上禁止运行脚本","data":{"date":"2021/8/18 11:09:24"}},{"label":"windows上_node-sass_less编译失败的终极解决方案","key":"npm_yarnwindows上_node-sass_less编译失败的终极解决方案","data":{"date":"2021/11/12 3:54:05"}},{"label":"yarn_无法加载文件","key":"npm_yarnyarn_无法加载文件","data":{"date":"2021/9/5 8:04:04"}},{"label":"使用npm给yarn升级","key":"npm_yarn使用npm给yarn升级","data":{"date":"2021-12-16 00:09:33"}}]},{"label":"other","key":"前端other","children":[{"label":"区块链学习-常用链接和教程","key":"other区块链学习-常用链接和教程","data":{"date":"2021/6/8 6:37:40"}}]},{"label":"油猴","key":"前端油猴","children":[{"label":"两个小时写了一个无广告版_百度搜索","key":"油猴两个小时写了一个无广告版_百度搜索","data":{"date":"2018-10-24 03:50:01"}},{"label":"代理工具_Whistle_页面显示优化脚本","key":"油猴代理工具_Whistle_页面显示优化脚本","data":{"date":"2020/9/23 1:26:37"}},{"label":"基于_Tampermonkey插件的_百度广告屏蔽脚本","key":"油猴基于_Tampermonkey插件的_百度广告屏蔽脚本","data":{"date":"2017-05-17 12:05:10"}},{"label":"工作-gitlab项目_提交合并请求时_自动识别分支","key":"油猴工作-gitlab项目_提交合并请求时_自动识别分支","data":{"date":"2020/9/17 3:45:25"}},{"label":"工作辅助工具","key":"油猴工作辅助工具","data":{"date":"2021/9/14 7:20:01"}},{"label":"把_Tampermonkey_功能放到全局","key":"油猴把_Tampermonkey_功能放到全局","data":{"date":"2021/9/14 10:56:54"}},{"label":"摹客ui稿web样式转化成ReactNative格式","key":"油猴摹客ui稿web样式转化成ReactNative格式","data":{"date":"2020/9/17 3:51:35"}},{"label":"油猴脚本开发文档-Tampermonkey_Documention_api","key":"油猴油猴脚本开发文档-Tampermonkey_Documention_api","data":{"date":"2021/9/14 2:08:10"}},{"label":"浏览器插件离线包","key":"油猴浏览器插件离线包","data":{"date":"2021/3/23 2:49:05"}},{"label":"清除cnblog广告_清爽页面","key":"油猴清除cnblog广告_清爽页面","data":{"date":"2020/9/17 4:05:39"}},{"label":"清除csdn广告_清爽页面","key":"油猴清除csdn广告_清爽页面","data":{"date":"2020/9/17 4:01:41"}},{"label":"第三方链接自动跳转-知乎微博csdn等","key":"油猴第三方链接自动跳转-知乎微博csdn等","data":{"date":"2021/6/9 2:25:59"}},{"label":"简单几行代码_写一个百度广告屏蔽插件_爽到爆","key":"油猴简单几行代码_写一个百度广告屏蔽插件_爽到爆","data":{"date":"2017-09-13 05:19:36"}}]},{"label":"问题","key":"前端问题","children":[{"label":"Access-Control-Allow-Origin_如何设置多个值呢","key":"问题Access-Control-Allow-Origin_如何设置多个值呢","data":{"date":"2017-04-06 10:23:04"}},{"label":"ajax请求图片_二进制形式显示图片有问题","key":"问题ajax请求图片_二进制形式显示图片有问题","data":{"date":"2018-07-23 10:20:42"}},{"label":"avalonjs_对body之外的绑定无效","key":"问题avalonjs_对body之外的绑定无效","data":{"date":"2016-12-27 12:00:10"}},{"label":"axios_post请求_控制台查看却是OPTIONS_不是post请求","key":"问题axios_post请求_控制台查看却是OPTIONS_不是post请求","data":{"date":"2017-09-29 11:29:56"}},{"label":"cdn上css文件引入页面后_response为空","key":"问题cdn上css文件引入页面后_response为空","data":{"date":"2016-05-31 09:19:34"}},{"label":"chrome_alarms没起作用_","key":"问题chrome_alarms没起作用_","data":{"date":"2016-11-16 12:46:36"}},{"label":"css,js预编译如何保留头部注释信息_","key":"问题css,js预编译如何保留头部注释信息_","data":{"date":"2016-06-01 01:49:43"}},{"label":"css怎么修改图片加载失败的小图标","key":"问题css怎么修改图片加载失败的小图标","data":{"date":"2018-05-02 06:49:08"}},{"label":"curl_请求参数分析","key":"问题curl_请求参数分析","data":{"date":"2018-03-29 06:30:54"}},{"label":"electron_使用淘宝镜像出现404问题","key":"问题electron_使用淘宝镜像出现404问题","data":{"date":"2020-03-18 07:59:56"}},{"label":"h5页面在iphone上字体变形","key":"问题h5页面在iphone上字体变形","data":{"date":"2017-01-10 03:31:47"}},{"label":"input_type=file_的_maxLength是多少","key":"问题input_type=file_的_maxLength是多少","data":{"date":"2016-03-28 11:27:57"}},{"label":"javascript如何判断浏览器是否支持_引号_","key":"问题javascript如何判断浏览器是否支持_引号_","data":{"date":"2016-10-28 02:37:41"}},{"label":"js中科学计数法转数字的问题","key":"问题js中科学计数法转数字的问题","data":{"date":"2018-03-23 04:39:33"}},{"label":"js事件冒泡和捕获问题在block和inline上的不同表现","key":"问题js事件冒泡和捕获问题在block和inline上的不同表现","data":{"date":"2016-06-15 05:53:52"}},{"label":"js处理大数字的问题","key":"问题js处理大数字的问题","data":{"date":"2019-02-26 01:12:40"}},{"label":"js正则不支持持后瞻的问题","key":"问题js正则不支持持后瞻的问题","data":{"date":"2016-04-24 04:17:30"}},{"label":"js正则怎么删除单行注释_","key":"问题js正则怎么删除单行注释_","data":{"date":"2018-04-20 11:21:23"}},{"label":"npm_-v_一直卡住","key":"问题npm_-v_一直卡住","data":{"date":"2019-11-10 01:25:24"}},{"label":"package_json中的node-sass无法安装","key":"问题package_json中的node-sass无法安装","data":{"date":"2017-09-13 03:26:10"}},{"label":"sass_mixin问题","key":"问题sass_mixin问题","data":{"date":"2017-01-09 01:56:16"}},{"label":"sbulime_插件_HTML-CSS-JS_Prettify_的_bug","key":"问题sbulime_插件_HTML-CSS-JS_Prettify_的_bug","data":{"date":"2018-11-21 01:30:22"}},{"label":"vue-i18n中语言项不能使用对象_","key":"问题vue-i18n中语言项不能使用对象_","data":{"date":"2020-05-13 10:11:03"}},{"label":"vue-router_能实现pushstate模式进行query进行传参吗_","key":"问题vue-router_能实现pushstate模式进行query进行传参吗_","data":{"date":"2018-08-25 08:03:29"}},{"label":"vue2_0_router内watch监听不到route变化_","key":"问题vue2_0_router内watch监听不到route变化_","data":{"date":"2018-06-05 01:27:45"}},{"label":"vue2_el不能是标签_必须是body内部一个标签的id吗","key":"问题vue2_el不能是标签_必须是body内部一个标签的id吗","data":{"date":"2016-10-27 02:10:04"}},{"label":"vue2_出现绑定不解析的问题_attr=_quot;obj_quot;_变成了_attr=_object_object_","key":"问题vue2_出现绑定不解析的问题_attr=_quot;obj_quot;_变成了_attr=_object_object_","data":{"date":"2017-04-20 03:06:23"}},{"label":"vue2如何实现数组的某一项变化_给这一项添加临时特效","key":"问题vue2如何实现数组的某一项变化_给这一项添加临时特效","data":{"date":"2017-12-15 10:52:30"}},{"label":"vue_router_在template中循环时_不能显示带有参数的路由地址_","key":"问题vue_router_在template中循环时_不能显示带有参数的路由地址_","data":{"date":"2017-10-24 07:17:21"}},{"label":"vue_双向绑定问题_emit无效","key":"问题vue_双向绑定问题_emit无效","data":{"date":"2017-03-15 11:43:59"}},{"label":"vue_多次调用组件冲突","key":"问题vue_多次调用组件冲突","data":{"date":"2018-05-04 04:03:54"}},{"label":"vue_自动添加前缀问题","key":"问题vue_自动添加前缀问题","data":{"date":"2016-12-20 02:03:12"}},{"label":"webpack中的externals无效是怎么回事_","key":"问题webpack中的externals无效是怎么回事_","data":{"date":"2019-11-04 04:55:00"}},{"label":"webstorm出现提示时_无法执行Ctrl_V","key":"问题webstorm出现提示时_无法执行Ctrl_V","data":{"date":"2020-02-23 09:01:00"}},{"label":"一个swiperjs的网格布局问题","key":"问题一个swiperjs的网格布局问题","data":{"date":"2018-01-11 10:44:35"}},{"label":"一个简单的vue_router_异步组件的问题","key":"问题一个简单的vue_router_异步组件的问题","data":{"date":"2018-03-24 09:59:35"}},{"label":"不确定图片高度情况下_如何实现瀑布流布局_","key":"问题不确定图片高度情况下_如何实现瀑布流布局_","data":{"date":"2016-05-18 03:21:26"}},{"label":"使用axios的post请求_请求参数好像有问题啊","key":"问题使用axios的post请求_请求参数好像有问题啊","data":{"date":"2017-09-29 01:01:54"}},{"label":"如何比较版本号大小类似9_11_1和9_2_9","key":"问题如何比较版本号大小类似9_11_1和9_2_9","data":{"date":"2017-01-12 03:48:46"}},{"label":"如何给vue异步组件绑定事件","key":"问题如何给vue异步组件绑定事件","data":{"date":"2016-06-17 11:33:52"}},{"label":"安卓微信中_select背景色无法去掉_","key":"问题安卓微信中_select背景色无法去掉_","data":{"date":"2018-11-21 11:41:15"}},{"label":"安卓手机中使用html的input_file_获取不到文件类型和文件名","key":"问题安卓手机中使用html的input_file_获取不到文件类型和文件名","data":{"date":"2017-04-27 07:30:00"}},{"label":"定义了一个vue全局方法_不能再vuex中进行调用","key":"问题定义了一个vue全局方法_不能再vuex中进行调用","data":{"date":"2018-05-18 10:40:11"}},{"label":"微信分享_icon图片不显示问题","key":"问题微信分享_icon图片不显示问题","data":{"date":"2016-08-23 04:37:32"}},{"label":"怎么解决promise只执行一次的问题","key":"问题怎么解决promise只执行一次的问题","data":{"date":"2018-09-29 01:49:23"}},{"label":"怎样同时启动gulp和json-server服务_","key":"问题怎样同时启动gulp和json-server服务_","data":{"date":"2016-07-20 06:36:25"}},{"label":"正则匹配单行注释问题","key":"问题正则匹配单行注释问题","data":{"date":"2018-10-09 06:39:47"}},{"label":"正则如何匹配完整的script标签","key":"问题正则如何匹配完整的script标签","data":{"date":"2018-04-24 05:10:37"}},{"label":"正则怎么匹配_ffffff,_000000,而不识别_fff000","key":"问题正则怎么匹配_ffffff,_000000,而不识别_fff000","data":{"date":"2018-05-11 11:18:25"}},{"label":"求哪几个数字之和接近某一个给定的值_小于等于_","key":"问题求哪几个数字之和接近某一个给定的值_小于等于_","data":{"date":"2016-06-10 09:28:52"}},{"label":"移动端cursor_pointer问题","key":"问题移动端cursor_pointer问题","data":{"date":"2016-10-25 04:00:10"}},{"label":"美团网页的header中有一个x-for-with是如何加密的_","key":"问题美团网页的header中有一个x-for-with是如何加密的_","data":{"date":"2019-04-15 06:42:02"}},{"label":"获取js点击点相对被点击元素的位置_click与touch的区别","key":"问题获取js点击点相对被点击元素的位置_click与touch的区别","data":{"date":"2016-06-16 11:32:18"}},{"label":"谷歌翻译_语音翻译接口是怎么提交语音的_","key":"问题谷歌翻译_语音翻译接口是怎么提交语音的_","data":{"date":"2018-10-24 11:06:48"}}]}]},{"label":"移动端","key":"移动端","children":[{"label":"Android Studio","key":"移动端Android Studio","children":[{"label":"Android_Studio新建项目时_没有flutter选项_","key":"Android StudioAndroid_Studio新建项目时_没有flutter选项_","data":{"date":"2021/7/27 11:24:17"}}]},{"label":"android","key":"移动端android","children":[{"label":"android项目启动报错_java.util.concurrent.ExecutionException","key":"androidandroid项目启动报错_java.util.concurrent.ExecutionException","data":{"date":"2021/6/26 12:52:24"}},{"label":"浏览器不支持double类型引发的血案","key":"android浏览器不支持double类型引发的血案","data":{"date":"2021/7/3 7:21:57"}}]},{"label":"flutter","key":"移动端flutter","children":[{"label":"Flutter_报错_setState()_called_after_dispose()","key":"flutterFlutter_报错_setState()_called_after_dispose()","data":{"date":"2021/7/6 11:27:16"}},{"label":"The_flutter_SDK_is_incomplete=Flutter_SDK_安装不完整","key":"flutterThe_flutter_SDK_is_incomplete=Flutter_SDK_安装不完整","data":{"date":"2021/7/27 11:34:35"}},{"label":"flutter_build_时报错_fatal_error_Flutter_Flutter.h_file_not_found","key":"flutterflutter_build_时报错_fatal_error_Flutter_Flutter.h_file_not_found","data":{"date":"2021/7/14 10:33:29"}},{"label":"flutter函数形参是必选项","key":"flutterflutter函数形参是必选项","data":{"date":"2021/7/17 9:19:55"}},{"label":"flutter文档链接","key":"flutterflutter文档链接","data":{"date":"2021/6/30 11:42:11"}},{"label":"flutter环境搭建_（windows）","key":"flutterflutter环境搭建_（windows）","data":{"date":"2021/6/29 4:15:03"}},{"label":"为什么flutter_中initState不执行_","key":"flutter为什么flutter_中initState不执行_","data":{"date":"2021/7/1 7:39:40"}},{"label":"运行flutter应用时_长时间卡在Running_Gradle_task_assembleDebug_","key":"flutter运行flutter应用时_长时间卡在Running_Gradle_task_assembleDebug_","data":{"date":"2019-12-31 01:55:10"}}]},{"label":"xcode","key":"移动端xcode","children":[{"label":"Mac_解决_gyp_No_Xcode_or_CLT_version_detected_报错","key":"xcodeMac_解决_gyp_No_Xcode_or_CLT_version_detected_报错","data":{"date":"2021/5/18 7:04:19"}}]},{"label":"问题","key":"移动端问题","children":[{"label":"swift_3的一个helloworld级别的错误","key":"问题swift_3的一个helloworld级别的错误","data":{"date":"2017-11-22 09:59:03"}}]}]},{"label":"系统","key":"系统","children":[{"label":"MongoDB","key":"系统MongoDB","children":[{"label":"MongoDB学习1-的下载下载链接","key":"MongoDBMongoDB学习1-的下载下载链接","data":{"date":"2020/12/5 1:18:38"}}]},{"label":"nginx","key":"系统nginx","children":[{"label":"nginx远程接口到本地使用","key":"nginxnginx远程接口到本地使用","data":{"date":"2017-09-29 12:40:56"}},{"label":"一段万能的nginx接口反向代理配置","key":"nginx一段万能的nginx接口反向代理配置","data":{"date":"2018-09-30 05:20:16"}}]},{"label":"nodejs","key":"系统nodejs","children":[{"label":"http和http2的区别（代码示例）","key":"nodejshttp和http2的区别（代码示例）","data":{"date":"2021/1/10 11:33:22"}},{"label":"nodejs_压缩图片-支持jpg和png","key":"nodejsnodejs_压缩图片-支持jpg和png","data":{"date":"2021/5/28 1:00:25"}},{"label":"nodejs使用canvas合成图片","key":"nodejsnodejs使用canvas合成图片","data":{"date":"2021/5/27 7:31:41"}},{"label":"nodejs使用socket5进行代理请求","key":"nodejsnodejs使用socket5进行代理请求","data":{"date":"2020-02-20 05:14:33"}},{"label":"nodejs做了一个网易相册全量下载工具","key":"nodejsnodejs做了一个网易相册全量下载工具","data":{"date":"2019-03-14 04:19:07"}},{"label":"nodejs提取gif中的图片","key":"nodejsnodejs提取gif中的图片","data":{"date":"2021/6/9 11:36:41"}},{"label":"nodejs的http_get,http_request怎么优雅的添加timeout_","key":"nodejsnodejs的http_get,http_request怎么优雅的添加timeout_","data":{"date":"2020-02-18 11:06:48"}},{"label":"从gif提取所有图片","key":"nodejs从gif提取所有图片","data":{"date":"2021/6/9 12:43:26"}},{"label":"使用openssl生成证书","key":"nodejs使用openssl生成证书","data":{"date":"2021-12-24 15:23:34"}},{"label":"前端工程师通过nodejs链接linux_并上传代码进行半自动化更新_省去ssh_ftp的链接工具","key":"nodejs前端工程师通过nodejs链接linux_并上传代码进行半自动化更新_省去ssh_ftp的链接工具","data":{"date":"2019-04-25 04:38:40"}},{"label":"简易搭建nodejs服务器","key":"nodejs简易搭建nodejs服务器","data":{"date":"2021-12-24 13:35:46"}}]},{"label":"php","key":"系统php","children":[{"label":"PHP获取IP地址及根据IP判断城市实现城市切换或跳转","key":"phpPHP获取IP地址及根据IP判断城市实现城市切换或跳转","data":{"date":"2014/4/29 5:27:00"}},{"label":"php_将Unicode_转成汉字","key":"phpphp_将Unicode_转成汉字","data":{"date":"2014/5/5 3:23:00"}},{"label":"php_获取_手机浏览器的信息_获取手机号","key":"phpphp_获取_手机浏览器的信息_获取手机号","data":{"date":"2014/5/3 11:33:00"}},{"label":"php判断浏览器的相关文章_教程_源码","key":"phpphp判断浏览器的相关文章_教程_源码","data":{"date":"2014/5/3 11:38:00"}},{"label":"php监听客户端连接状态","key":"phpphp监听客户端连接状态","data":{"date":"2014/5/3 11:37:00"}},{"label":"windows_10_中_java_设置path不起作用","key":"phpwindows_10_中_java_设置path不起作用","data":{"date":"2017-07-22 02:25:56"}}]},{"label":"windows","key":"系统windows","children":[{"label":"1_PC微信Hook实战记录1_找到个人信息","key":"windows1_PC微信Hook实战记录1_找到个人信息","data":{"date":"2020/11/11 6:43:05"}},{"label":"2_微信Hook实战记录2_动手实现dll内存插入器","key":"windows2_微信Hook实战记录2_动手实现dll内存插入器","data":{"date":"2020/11/11 6:46:28"}},{"label":"Windows10系统如何安装ms-windows-store","key":"windowsWindows10系统如何安装ms-windows-store","data":{"date":"2020/11/23 1:35:12"}},{"label":"win10_微信多开_企微多开","key":"windowswin10_微信多开_企微多开","data":{"date":"2020/9/21 11:19:47"}},{"label":"window10_的10000端口莫名被占用_一步步定位到找到根源","key":"windowswindow10_的10000端口莫名被占用_一步步定位到找到根源","data":{"date":"2021/4/14 1:47:05"}},{"label":"windows查看支持最大内存","key":"windowswindows查看支持最大内存","data":{"date":"2021/9/5 6:42:29"}},{"label":"企业微信Windows版本调试（底部有mac教程）","key":"windows企业微信Windows版本调试（底部有mac教程）","data":{"date":"2020/11/17 12:42:16"}},{"label":"安装Puppeteer时跳过Chromium下载","key":"windows安装Puppeteer时跳过Chromium下载","data":{"date":"2023-01-22 08:26:07"}},{"label":"微信Hook逆向教程完整视频","key":"windows微信Hook逆向教程完整视频","data":{"date":"2020/11/11 6:52:55"}},{"label":"微信逆向之朋友圈","key":"windows微信逆向之朋友圈","data":{"date":"2020/11/11 7:04:08"}},{"label":"怎么修改hosts文件","key":"windows怎么修改hosts文件","data":{"date":"2021/5/25 9:03:29"}},{"label":"联想笔记本e480_切换电源时黑屏问题","key":"windows联想笔记本e480_切换电源时黑屏问题","data":{"date":"2021/1/20 11:11:28"}}]},{"label":"代理","key":"系统代理","children":[{"label":"Charles_青花瓷代理工具注册码","key":"代理Charles_青花瓷代理工具注册码","data":{"date":"2020/11/20 11:25:13"}},{"label":"SwitchyOmega_Chrome_Win10_环境下_SOCKS5_协议问题","key":"代理SwitchyOmega_Chrome_Win10_环境下_SOCKS5_协议问题","data":{"date":"2020/11/24 1:00:52"}},{"label":"whistle代理配置","key":"代理whistle代理配置","data":{"date":"2021/3/1 7:27:28"}},{"label":"whistle前端开发代理工具使用入门","key":"代理whistle前端开发代理工具使用入门","data":{"date":"2021/5/14 10:59:34"}}]},{"label":"问题","key":"系统问题","children":[{"label":"java怎么将utc字符串转成时间戳_","key":"问题java怎么将utc字符串转成时间戳_","data":{"date":"2018-07-06 02:36:16"}},{"label":"nginx_反向代理配置后_首页404","key":"问题nginx_反向代理配置后_首页404","data":{"date":"2018-06-17 07:50:52"}},{"label":"nodejs_如何模拟请求一个ws_socket的请求_","key":"问题nodejs_如何模拟请求一个ws_socket的请求_","data":{"date":"2019-04-12 03:37:26"}},{"label":"nodejs_的watch执行回调两次_","key":"问题nodejs_的watch执行回调两次_","data":{"date":"2018-04-13 05:04:21"}},{"label":"pc微信上传文件_不能切片上传","key":"问题pc微信上传文件_不能切片上传","data":{"date":"2017-06-05 06:33:20"}},{"label":"使用itchat时_消息更新不及时_需要缩放一下命令行窗口_才能处罚更新_这是怎么回事_","key":"问题使用itchat时_消息更新不及时_需要缩放一下命令行窗口_才能处罚更新_这是怎么回事_","data":{"date":"2019-02-13 04:18:08"}},{"label":"使用nodejs_如何模拟一个socket请求_","key":"问题使用nodejs_如何模拟一个socket请求_","data":{"date":"2019-05-15 06:21:44"}},{"label":"使用phpstudy的apache开启ssl服务_通过https访问网页_拒绝请求_无法访问","key":"问题使用phpstudy的apache开启ssl服务_通过https访问网页_拒绝请求_无法访问","data":{"date":"2017-09-29 11:15:53"}},{"label":"如何使用nodejs的http模块模拟请求_并带上navigator等信息","key":"问题如何使用nodejs的http模块模拟请求_并带上navigator等信息","data":{"date":"2019-03-19 05:31:16"}},{"label":"给服务器加了一个开机执行脚本_最后加了一行exit_0_,现在连不上服务器了_急急急！！！","key":"问题给服务器加了一个开机执行脚本_最后加了一行exit_0_,现在连不上服务器了_急急急！！！","data":{"date":"2018-12-29 06:55:32"}}]}]},{"label":"音视频","key":"音视频","children":[{"label":"ffmpeg","key":"音视频ffmpeg","children":[{"label":"ffmpeg_sox实现录音降噪","key":"ffmpegffmpeg_sox实现录音降噪","data":{"date":"2022-01-05 21:43:45"}},{"label":"ffmpeg参数详解","key":"ffmpegffmpeg参数详解","data":{"date":"2022-01-05 21:38:23"}},{"label":"ffmpeg录屏录音","key":"ffmpegffmpeg录屏录音","data":{"date":"2022-01-05 21:23:25"}},{"label":"ffmpeg截取视频","key":"ffmpegffmpeg截取视频","data":{"date":"2021-12-30 21:28:27"}},{"label":"ffmpeg-doc","key":"ffmpegffmpeg-doc","data":{"date":"2021-12-27 20:57:01"}},{"label":"ffmpeg命令行map参数选择音视频流","key":"ffmpegffmpeg命令行map参数选择音视频流","data":{"date":"2021-12-27 20:54:45"}},{"label":"ffmpeg多视频多音轨合并","key":"ffmpegffmpeg多视频多音轨合并","data":{"date":"2021-12-27 20:45:00"}},{"label":"ffmpeg基本用法","key":"ffmpegffmpeg基本用法","data":{"date":"2021-12-27 08:41:52"}},{"label":"使用ffmpeg分离视频流和音频流","key":"ffmpeg使用ffmpeg分离视频流和音频流","data":{"date":"2021-12-27 08:10:42"}},{"label":"ffmpeg压缩视频","key":"ffmpegffmpeg压缩视频","data":{"date":"2021/2/27 1:43:01"}},{"label":"ffmpeg把本地文件作为直播源","key":"ffmpegffmpeg把本地文件作为直播源","data":{"date":"2021/2/27 1:41:23"}},{"label":"ffmpeg参数说明","key":"ffmpegffmpeg参数说明","data":{"date":"2021/2/27 1:40:05"}},{"label":"ffmpeg_切割mp4为m3u8格式","key":"ffmpegffmpeg_切割mp4为m3u8格式","data":{"date":"2021/2/27 1:36:44"}}]}]}]},"__N_SSG":true}